; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\obj\regctrl.o --depend=.\obj\regctrl.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\Nuvoton -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\regctrl.crf Users\RegCtrl.c]
                          THUMB

                          AREA ||i.RcGetReg||, CODE, READONLY, ALIGN=2

                  RcGetReg PROC
;;;142    **************************************************/
;;;143    unsigned char RcGetReg(unsigned char RegAddr)
000000  b538              PUSH     {r3-r5,lr}
;;;144    {
000002  4604              MOV      r4,r0
;;;145        unsigned char RegVal;
;;;146        short status;
;;;147    
;;;148    	// configure transaction length as 8 bits
;;;149    	SPI_SetBitLength(SPI1, 8);	
000004  2108              MOVS     r1,#8
000006  480f              LDR      r0,|L1.68|
000008  f7fffffe          BL       SPI_SetBitLength
;;;150    
;;;151    	// /CS: active
;;;152    	SPI_SetSS(SPI1, SPI_SS0);	
00000c  2101              MOVS     r1,#1
00000e  480d              LDR      r0,|L1.68|
000010  f7fffffe          BL       SPI_SetSS
;;;153    
;;;154        RegAddr = ((RegAddr & 0x3f) << 1) | 0x80;   //code the first byte
000014  06a0              LSLS     r0,r4,#26
000016  0e40              LSRS     r0,r0,#25
000018  3080              ADDS     r0,r0,#0x80
00001a  b2c4              UXTB     r4,r0
;;;155        putchar(RegAddr);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       putchar
;;;156        status = getchar(&RegVal, 10000);
000022  4909              LDR      r1,|L1.72|
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       getchar
00002a  4605              MOV      r5,r0
;;;157    	
;;;158    	SPI_ClrSS(SPI1, SPI_SS0);
00002c  2101              MOVS     r1,#1
00002e  4805              LDR      r0,|L1.68|
000030  f7fffffe          BL       SPI_ClrSS
;;;159    	 
;;;160        if(status != STATUS_SUCCESS)
000034  2d00              CMP      r5,#0
000036  d001              BEQ      |L1.60|
;;;161            return 0xff;
000038  20ff              MOVS     r0,#0xff
                  |L1.58|
;;;162        return RegVal;
;;;163    }
00003a  bd38              POP      {r3-r5,pc}
                  |L1.60|
00003c  4668              MOV      r0,sp                 ;162
00003e  7800              LDRB     r0,[r0,#0]            ;162
000040  e7fb              B        |L1.58|
;;;164    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x40130000
                  |L1.72|
                          DCD      0x00002710

                          AREA ||i.RcModifyReg||, CODE, READONLY, ALIGN=1

                  RcModifyReg PROC
;;;175    **************************************************/
;;;176    void RcModifyReg(unsigned char RegAddr, unsigned char ModifyVal, unsigned char MaskByte)
000000  b5f8              PUSH     {r3-r7,lr}
;;;177    {
000002  4607              MOV      r7,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;178        unsigned char RegVal;
;;;179        RegVal = RcGetReg(RegAddr);
000008  4638              MOV      r0,r7
00000a  f7fffffe          BL       RcGetReg
00000e  4605              MOV      r5,r0
;;;180        if(ModifyVal)
000010  2e00              CMP      r6,#0
000012  d003              BEQ      |L2.28|
;;;181        {
;;;182            RegVal |= MaskByte;
000014  4628              MOV      r0,r5
000016  4320              ORRS     r0,r0,r4
000018  4605              MOV      r5,r0
00001a  e002              B        |L2.34|
                  |L2.28|
;;;183        }
;;;184        else
;;;185        {
;;;186            RegVal &= (~MaskByte);
00001c  4628              MOV      r0,r5
00001e  43a0              BICS     r0,r0,r4
000020  4605              MOV      r5,r0
                  |L2.34|
;;;187        }
;;;188        RcSetReg(RegAddr, RegVal);
000022  4629              MOV      r1,r5
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       RcSetReg
;;;189    }
00002a  bdf8              POP      {r3-r7,pc}
;;;190    
                          ENDP


                          AREA ||i.RcSetReg||, CODE, READONLY, ALIGN=2

                  RcSetReg PROC
;;;109    **************************************************/
;;;110    void RcSetReg(unsigned char RegAddr, unsigned char RegVal)
000000  b5f8              PUSH     {r3-r7,lr}
;;;111    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;112        unsigned char EchoByte;
;;;113        short status;
;;;114    
;;;115        /* SPI RC522 */
;;;116    	// configure transaction length as 8 bits
;;;117    	SPI_SetBitLength(SPI1, 8);	
000006  2108              MOVS     r1,#8
000008  480d              LDR      r0,|L3.64|
00000a  f7fffffe          BL       SPI_SetBitLength
;;;118    
;;;119    	// /CS: active
;;;120    	SPI_SetSS(SPI1, SPI_SS0);
00000e  2101              MOVS     r1,#1
000010  480b              LDR      r0,|L3.64|
000012  f7fffffe          BL       SPI_SetSS
;;;121    
;;;122        RegAddr = (RegAddr << 1) & 0x7E;   //code the first byte
000016  0060              LSLS     r0,r4,#1
000018  217e              MOVS     r1,#0x7e
00001a  4008              ANDS     r0,r0,r1
00001c  4604              MOV      r4,r0
;;;123        putchar(RegAddr);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       putchar
;;;124        putchar(RegVal);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       putchar
;;;125        status = getchar(&EchoByte, 10000);
00002a  4906              LDR      r1,|L3.68|
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       getchar
000032  4606              MOV      r6,r0
;;;126    
;;;127    	if(status)
;;;128    	{
;;;129    	}
;;;130    
;;;131    	SPI_ClrSS(SPI1, SPI_SS0); 
000034  2101              MOVS     r1,#1
000036  4802              LDR      r0,|L3.64|
000038  f7fffffe          BL       SPI_ClrSS
;;;132    }
00003c  bdf8              POP      {r3-r7,pc}
;;;133    
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      0x40130000
                  |L3.68|
                          DCD      0x00002710

                          AREA ||i.SPI_ClrSS||, CODE, READONLY, ALIGN=1

                  SPI_ClrSS PROC
;;;247      */
;;;248    static __INLINE void SPI_ClrSS(SPI_TypeDef *SpiPort, SPI_SLAVE_SEL eSlaveSel)
000000  68c2              LDR      r2,[r0,#0xc]
;;;249    {	
;;;250    	SpiPort->SSR &= ~eSlaveSel;	
000002  438a              BICS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;251    }
000006  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.SPI_IsBusy||, CODE, READONLY, ALIGN=1

                  SPI_IsBusy PROC
;;;258      */
;;;259    static __INLINE uint8_t SPI_IsBusy(SPI_TypeDef *SpiPort)
000000  4601              MOV      r1,r0
;;;260    {
;;;261        return ((SpiPort->CTL & SPI_CTL_GO_BUSY)?TRUE:FALSE);
000002  6808              LDR      r0,[r1,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
;;;262    }
000008  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.SPI_SetSS||, CODE, READONLY, ALIGN=1

                  SPI_SetSS PROC
;;;235      */
;;;236    static __INLINE void SPI_SetSS(SPI_TypeDef *SpiPort, SPI_SLAVE_SEL eSlaveSel)
000000  68c2              LDR      r2,[r0,#0xc]
;;;237    {
;;;238        SpiPort->SSR = (SpiPort->SSR & ~SPI_SSR_SSR_MASK) | eSlaveSel;
000002  0892              LSRS     r2,r2,#2
000004  0092              LSLS     r2,r2,#2
000006  430a              ORRS     r2,r2,r1
000008  60c2              STR      r2,[r0,#0xc]
;;;239    }
00000a  4770              BX       lr
;;;240    
                          ENDP


                          AREA ||i.getchar||, CODE, READONLY, ALIGN=2

                  getchar PROC
;;;73     **************************************************/
;;;74     short getchar(unsigned char *ch, unsigned int WaitTime)
000000  b5f8              PUSH     {r3-r7,lr}
;;;75     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;76         unsigned int j;
;;;77     	uint32_t ucResult;
;;;78     
;;;79         j=0;
000006  2500              MOVS     r5,#0
;;;80         while (SPI_IsBusy(SPI1))
000008  e003              B        |L7.18|
                  |L7.10|
;;;81     	{
;;;82     		j++;
00000a  1c6d              ADDS     r5,r5,#1
;;;83     		if(j>=WaitTime)          //avoid endless loop
00000c  42a5              CMP      r5,r4
00000e  d300              BCC      |L7.18|
;;;84     			break;
000010  e004              B        |L7.28|
                  |L7.18|
000012  480b              LDR      r0,|L7.64|
000014  f7fffffe          BL       SPI_IsBusy
000018  2800              CMP      r0,#0                 ;80
00001a  d1f6              BNE      |L7.10|
                  |L7.28|
00001c  bf00              NOP      
;;;85     	}
;;;86     
;;;87     	if(j<WaitTime)
00001e  42a5              CMP      r5,r4
000020  d20c              BCS      |L7.60|
;;;88     	{
;;;89     		SPI_SingleRead(SPI1, &ucResult);
000022  4669              MOV      r1,sp
000024  4806              LDR      r0,|L7.64|
000026  f7fffffe          BL       SPI_SingleRead
;;;90     		*ch = (unsigned char)ucResult;
00002a  9800              LDR      r0,[sp,#0]
00002c  7030              STRB     r0,[r6,#0]
;;;91     
;;;92     		// wait
;;;93     		while (SPI_IsBusy(SPI1)) {}
00002e  bf00              NOP      
                  |L7.48|
000030  4803              LDR      r0,|L7.64|
000032  f7fffffe          BL       SPI_IsBusy
000036  2800              CMP      r0,#0
000038  d1fa              BNE      |L7.48|
                  |L7.58|
;;;94     
;;;95     		return STATUS_SUCCESS;
;;;96     	}
;;;97     	else
;;;98     	    return STATUS_IO_TIMEOUT;
;;;99     }
00003a  bdf8              POP      {r3-r7,pc}
                  |L7.60|
00003c  2001              MOVS     r0,#1                 ;98
00003e  e7fc              B        |L7.58|
;;;100    /*************************************************
                          ENDP

                  |L7.64|
                          DCD      0x40130000

                          AREA ||i.putchar||, CODE, READONLY, ALIGN=2

                  putchar PROC
;;;52     **************************************************/
;;;53     void putchar(unsigned char ch)
000000  b538              PUSH     {r3-r5,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55     	uint32_t temp;
;;;56     
;;;57     	temp = (uint32_t)ch;
000004  9400              STR      r4,[sp,#0]
;;;58         SPI_SingleWrite(SPI1, &temp);
000006  4669              MOV      r1,sp
000008  4804              LDR      r0,|L8.28|
00000a  f7fffffe          BL       SPI_SingleWrite
;;;59     	// wait
;;;60     	while (SPI_IsBusy(SPI1)) {}
00000e  bf00              NOP      
                  |L8.16|
000010  4802              LDR      r0,|L8.28|
000012  f7fffffe          BL       SPI_IsBusy
000016  2800              CMP      r0,#0
000018  d1fa              BNE      |L8.16|
;;;61     }
00001a  bd38              POP      {r3-r5,pc}
;;;62     
                          ENDP

                  |L8.28|
                          DCD      0x40130000
