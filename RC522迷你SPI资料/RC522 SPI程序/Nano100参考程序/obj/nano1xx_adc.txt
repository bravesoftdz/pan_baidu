; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\obj\nano1xx_adc.o --depend=.\obj\nano1xx_adc.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\Nuvoton -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\nano1xx_adc.crf Libraries\nano1xx_adc.c]
                          THUMB

                          AREA ||i.ADC_ConfigCal||, CODE, READONLY, ALIGN=2

                  ADC_ConfigCal PROC
;;;297      */
;;;298    void ADC_ConfigCal(uint8_t u8Enable, uint32_t u32Mode)
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300    
;;;301    	uint32_t reg;
;;;302    
;;;303    	assert_param((u32Mode == ADC_CALCTL_CALSEL) || (u32Mode == ADC_CALCTL_LOAD));
;;;304    
;;;305    	reg = ADC->CALCTL & ~(ADC_CALCTL_CALEN | ADC_CALCTL_CALSEL);
000002  4b08              LDR      r3,|L1.36|
000004  6a9b              LDR      r3,[r3,#0x28]
000006  2409              MOVS     r4,#9
000008  43a3              BICS     r3,r3,r4
00000a  461a              MOV      r2,r3
;;;306    	ADC->CALCTL = reg | u32Mode | (u8Enable == 0 ? 0 : 1);
00000c  4613              MOV      r3,r2
00000e  430b              ORRS     r3,r3,r1
000010  2800              CMP      r0,#0
000012  d001              BEQ      |L1.24|
000014  2401              MOVS     r4,#1
000016  e000              B        |L1.26|
                  |L1.24|
000018  2400              MOVS     r4,#0
                  |L1.26|
00001a  4323              ORRS     r3,r3,r4
00001c  4c01              LDR      r4,|L1.36|
00001e  62a3              STR      r3,[r4,#0x28]
;;;307    
;;;308    }
000020  bd10              POP      {r4,pc}
;;;309    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x400e0040

                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;60       */
;;;61     void ADC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63             ADC->CHER = 0;
000002  2000              MOVS     r0,#0
000004  4907              LDR      r1,|L2.36|
000006  60c8              STR      r0,[r1,#0xc]
;;;64             ADC->CR = 0;
000008  6088              STR      r0,[r1,#8]
;;;65             ADC->CMPR0 = 0;
00000a  6108              STR      r0,[r1,#0x10]
;;;66             ADC->CMPR1 = 0;
00000c  6148              STR      r0,[r1,#0x14]
;;;67             CLK->APBCLK &= ~CLK_APBCLK_ADC_EN;         /* ADC engine clock disable */
00000e  4806              LDR      r0,|L2.40|
000010  6880              LDR      r0,[r0,#8]
000012  0589              LSLS     r1,r1,#22
000014  4388              BICS     r0,r0,r1
000016  4904              LDR      r1,|L2.40|
000018  6088              STR      r0,[r1,#8]
;;;68     
;;;69             NVIC_DisableIRQ(ADC_IRQn);
00001a  201d              MOVS     r0,#0x1d
00001c  f7fffffe          BL       NVIC_DisableIRQ
;;;70     }
000020  bd10              POP      {r4,pc}
;;;71     
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x400e0040
                  |L2.40|
                          DCD      0x50000200

                          AREA ||i.ADC_DisableComp0Int||, CODE, READONLY, ALIGN=2

                  ADC_DisableComp0Int PROC
;;;120      */
;;;121    void ADC_DisableComp0Int(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123            ADC->CMPR0 &= ~ADC_CMPR_CMPIE;
000002  4809              LDR      r0,|L3.40|
000004  6900              LDR      r0,[r0,#0x10]
000006  2102              MOVS     r1,#2
000008  4388              BICS     r0,r0,r1
00000a  4907              LDR      r1,|L3.40|
00000c  6108              STR      r0,[r1,#0x10]
;;;124    
;;;125            if(!(ADC->CR & ADC_CR_ADIE))
00000e  4608              MOV      r0,r1
000010  6880              LDR      r0,[r0,#8]
000012  2102              MOVS     r1,#2
000014  4208              TST      r0,r1
000016  d106              BNE      |L3.38|
;;;126                if(!(ADC->CMPR1 & ADC_CMPR_CMPIE))
000018  4803              LDR      r0,|L3.40|
00001a  6940              LDR      r0,[r0,#0x14]
00001c  4208              TST      r0,r1
00001e  d102              BNE      |L3.38|
;;;127    		NVIC_DisableIRQ(ADC_IRQn);
000020  201d              MOVS     r0,#0x1d
000022  f7fffffe          BL       NVIC_DisableIRQ
                  |L3.38|
;;;128    }
000026  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  |L3.40|
                          DCD      0x400e0040

                          AREA ||i.ADC_DisableComp1Int||, CODE, READONLY, ALIGN=2

                  ADC_DisableComp1Int PROC
;;;148      */
;;;149    void ADC_DisableComp1Int(void)
000000  b510              PUSH     {r4,lr}
;;;150    {
;;;151            ADC->CMPR1 &= ~ADC_CMPR_CMPIE;
000002  4809              LDR      r0,|L4.40|
000004  6940              LDR      r0,[r0,#0x14]
000006  2102              MOVS     r1,#2
000008  4388              BICS     r0,r0,r1
00000a  4907              LDR      r1,|L4.40|
00000c  6148              STR      r0,[r1,#0x14]
;;;152    
;;;153            if(!(ADC->CR & ADC_CR_ADIE))
00000e  4608              MOV      r0,r1
000010  6880              LDR      r0,[r0,#8]
000012  2102              MOVS     r1,#2
000014  4208              TST      r0,r1
000016  d106              BNE      |L4.38|
;;;154                if(!(ADC->CMPR0 & ADC_CMPR_CMPIE))
000018  4803              LDR      r0,|L4.40|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  4208              TST      r0,r1
00001e  d102              BNE      |L4.38|
;;;155    		NVIC_DisableIRQ(ADC_IRQn);
000020  201d              MOVS     r0,#0x1d
000022  f7fffffe          BL       NVIC_DisableIRQ
                  |L4.38|
;;;156    
;;;157    }
000026  bd10              POP      {r4,pc}
;;;158    
                          ENDP

                  |L4.40|
                          DCD      0x400e0040

                          AREA ||i.ADC_DisableInt||, CODE, READONLY, ALIGN=2

                  ADC_DisableInt PROC
;;;92       */
;;;93     void ADC_DisableInt(void)
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95             ADC->CR &= ~ADC_CR_ADIE;
000002  4809              LDR      r0,|L5.40|
000004  6880              LDR      r0,[r0,#8]
000006  2102              MOVS     r1,#2
000008  4388              BICS     r0,r0,r1
00000a  4907              LDR      r1,|L5.40|
00000c  6088              STR      r0,[r1,#8]
;;;96             if(!(ADC->CMPR0 & ADC_CMPR_CMPIE))
00000e  4608              MOV      r0,r1
000010  6900              LDR      r0,[r0,#0x10]
000012  2102              MOVS     r1,#2
000014  4208              TST      r0,r1
000016  d106              BNE      |L5.38|
;;;97                 if(!(ADC->CMPR1 & ADC_CMPR_CMPIE))
000018  4803              LDR      r0,|L5.40|
00001a  6940              LDR      r0,[r0,#0x14]
00001c  4208              TST      r0,r1
00001e  d102              BNE      |L5.38|
;;;98     		NVIC_DisableIRQ(ADC_IRQn);
000020  201d              MOVS     r0,#0x1d
000022  f7fffffe          BL       NVIC_DisableIRQ
                  |L5.38|
;;;99     }
000026  bd10              POP      {r4,pc}
;;;100    
                          ENDP

                  |L5.40|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableComp0||, CODE, READONLY, ALIGN=2

                  ADC_EnableComp0 PROC
;;;227      */
;;;228    void ADC_EnableComp0(uint8_t u8ch,
000000  b530              PUSH     {r4,r5,lr}
;;;229                                 uint32_t u32Condition,
;;;230                                 uint16_t u16Data,
;;;231                                 uint8_t u8Count)
;;;232    {
;;;233            assert_param(u8ch < ADC_CH_NUM);
;;;234            assert_param(u16Data <= ADC_RESULT_RSLT_MASK);
;;;235            assert_param(u8Count <= (ADC_CMPR_CMPMATCNT_MASK + 1));
;;;236    	assert_param((u32Condition == ADC_CMPR_CMPCOND_GE) || (u32Condition == ADC_CMPR_CMPCOND_LT));
;;;237    
;;;238            ADC->CMPR0 = (u16Data << 16) | ((u8Count - 1) << 8) | (u8ch << 3) | u32Condition | ADC_CMPR_CMPEN;
000002  0414              LSLS     r4,r2,#16
000004  1e5d              SUBS     r5,r3,#1
000006  022d              LSLS     r5,r5,#8
000008  432c              ORRS     r4,r4,r5
00000a  00c5              LSLS     r5,r0,#3
00000c  432c              ORRS     r4,r4,r5
00000e  430c              ORRS     r4,r4,r1
000010  2501              MOVS     r5,#1
000012  432c              ORRS     r4,r4,r5
000014  4d01              LDR      r5,|L6.28|
000016  612c              STR      r4,[r5,#0x10]
;;;239    
;;;240    }
000018  bd30              POP      {r4,r5,pc}
;;;241    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableComp0Int||, CODE, READONLY, ALIGN=2

                  ADC_EnableComp0Int PROC
;;;106      */
;;;107    void ADC_EnableComp0Int(void)
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109    
;;;110            ADC->SR = ADC_SR_CMPF0;        /* clear the ADC comparator 1 interrupt flag for safe */
000002  2002              MOVS     r0,#2
000004  4905              LDR      r1,|L7.28|
000006  6188              STR      r0,[r1,#0x18]
;;;111            ADC->CMPR0 |= ADC_CMPR_CMPIE;
000008  4608              MOV      r0,r1
00000a  6900              LDR      r0,[r0,#0x10]
00000c  2102              MOVS     r1,#2
00000e  4308              ORRS     r0,r0,r1
000010  4902              LDR      r1,|L7.28|
000012  6108              STR      r0,[r1,#0x10]
;;;112            NVIC_EnableIRQ(ADC_IRQn);
000014  201d              MOVS     r0,#0x1d
000016  f7fffffe          BL       NVIC_EnableIRQ
;;;113    }
00001a  bd10              POP      {r4,pc}
;;;114    
                          ENDP

                  |L7.28|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableComp1||, CODE, READONLY, ALIGN=2

                  ADC_EnableComp1 PROC
;;;250      */
;;;251    void ADC_EnableComp1(uint8_t u8ch,
000000  b530              PUSH     {r4,r5,lr}
;;;252                                 uint32_t u32Condition,
;;;253                                 uint16_t u16Data,
;;;254                                 uint8_t u8Count)
;;;255    {
;;;256            assert_param(u8ch < ADC_CH_NUM);
;;;257            assert_param(u16Data <= ADC_RESULT_RSLT_MASK);
;;;258            assert_param(u8Count <= (ADC_CMPR_CMPMATCNT_MASK + 1));
;;;259    	assert_param((u32Condition == ADC_CMPR_CMPCOND_GE) || (u32Condition == ADC_CMPR_CMPCOND_LT));
;;;260    
;;;261            ADC->CMPR1 = (u16Data << 16) | ((u8Count - 1) << 8) | (u8ch << 3) | u32Condition | ADC_CMPR_CMPEN;
000002  0414              LSLS     r4,r2,#16
000004  1e5d              SUBS     r5,r3,#1
000006  022d              LSLS     r5,r5,#8
000008  432c              ORRS     r4,r4,r5
00000a  00c5              LSLS     r5,r0,#3
00000c  432c              ORRS     r4,r4,r5
00000e  430c              ORRS     r4,r4,r1
000010  2501              MOVS     r5,#1
000012  432c              ORRS     r4,r4,r5
000014  4d01              LDR      r5,|L8.28|
000016  616c              STR      r4,[r5,#0x14]
;;;262    
;;;263    }
000018  bd30              POP      {r4,r5,pc}
;;;264    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableComp1Int||, CODE, READONLY, ALIGN=2

                  ADC_EnableComp1Int PROC
;;;134      */
;;;135    void ADC_EnableComp1Int(void)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    
;;;138            ADC->SR = ADC_SR_CMPF1;        /* clear the ADC comparator 1 interrupt flag for safe */
000002  2004              MOVS     r0,#4
000004  4905              LDR      r1,|L9.28|
000006  6188              STR      r0,[r1,#0x18]
;;;139            ADC->CMPR1 |= ADC_CMPR_CMPIE;
000008  4608              MOV      r0,r1
00000a  6940              LDR      r0,[r0,#0x14]
00000c  2102              MOVS     r1,#2
00000e  4308              ORRS     r0,r0,r1
000010  4902              LDR      r1,|L9.28|
000012  6148              STR      r0,[r1,#0x14]
;;;140            NVIC_EnableIRQ(ADC_IRQn);
000014  201d              MOVS     r0,#0x1d
000016  f7fffffe          BL       NVIC_EnableIRQ
;;;141    }
00001a  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  |L9.28|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableExtTrigger||, CODE, READONLY, ALIGN=2

                  ADC_EnableExtTrigger PROC
;;;164      */
;;;165    void ADC_EnableExtTrigger(uint32_t u32Condition)
000000  4a06              LDR      r2,|L10.28|
;;;166    {
;;;167    	uint32_t reg;
;;;168    
;;;169    	assert_param((u32Condition == ADC_CR_TRGCOND_L_LEV) ||
;;;170    		(u32Condition == ADC_CR_TRGCOND_H_LEV) ||
;;;171    		(u32Condition == ADC_CR_TRGCOND_F_EDGE) ||
;;;172    		(u32Condition == ADC_CR_TRGCOND_R_EDGE));
;;;173    
;;;174    	reg = ADC->CR & ~(ADC_CR_TRGCOND_MASK);
000002  6892              LDR      r2,[r2,#8]
000004  23c0              MOVS     r3,#0xc0
000006  439a              BICS     r2,r2,r3
000008  4611              MOV      r1,r2
;;;175    	ADC->CR = reg | u32Condition | ADC_CR_TRGEN;
00000a  460a              MOV      r2,r1
00000c  4302              ORRS     r2,r2,r0
00000e  23ff              MOVS     r3,#0xff
000010  3301              ADDS     r3,#1
000012  431a              ORRS     r2,r2,r3
000014  4b01              LDR      r3,|L10.28|
000016  609a              STR      r2,[r3,#8]
;;;176    
;;;177    }
000018  4770              BX       lr
;;;178    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableInt||, CODE, READONLY, ALIGN=2

                  ADC_EnableInt PROC
;;;79       */
;;;80     void ADC_EnableInt(void)
000000  b510              PUSH     {r4,lr}
;;;81     {
;;;82     
;;;83             ADC->SR = ADC_SR_ADF;  // clear interrupt flag
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L11.28|
000006  6188              STR      r0,[r1,#0x18]
;;;84             ADC->CR |= ADC_CR_ADIE;
000008  4608              MOV      r0,r1
00000a  6880              LDR      r0,[r0,#8]
00000c  2102              MOVS     r1,#2
00000e  4308              ORRS     r0,r0,r1
000010  4902              LDR      r1,|L11.28|
000012  6088              STR      r0,[r1,#8]
;;;85             NVIC_EnableIRQ(ADC_IRQn);
000014  201d              MOVS     r0,#0x1d
000016  f7fffffe          BL       NVIC_EnableIRQ
;;;86     }
00001a  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  |L11.28|
                          DCD      0x400e0040

                          AREA ||i.ADC_EnableTimerTrigger||, CODE, READONLY, ALIGN=2

                  ADC_EnableTimerTrigger PROC
;;;272      */
;;;273    void ADC_EnableTimerTrigger(S_ADC_TIMER_TRIGGER_CFG *cfg)
000000  4a07              LDR      r2,|L12.32|
;;;274    {
;;;275    	uint32_t reg;
;;;276    
;;;277            assert_param(cfg != NULL);
;;;278            assert_param(cfg->u8Cnt != 0);
;;;279            assert_param((cfg->u32Src == ADC_CR_TMSEL_TMR0_CH0) ||
;;;280    		(cfg->u32Src == ADC_CR_TMSEL_TMR0_CH1) ||
;;;281    		(cfg->u32Src == ADC_CR_TMSEL_TMR1_CH0) ||
;;;282    		(cfg->u32Src == ADC_CR_TMSEL_TMR1_CH1));
;;;283    
;;;284    	reg = ADC->CR & ~(ADC_CR_TMSEL_MASK | ADC_CR_TMPDMACNT_MASK | ADC_CR_ADEN);
000002  6892              LDR      r2,[r2,#8]
000004  4b07              LDR      r3,|L12.36|
000006  401a              ANDS     r2,r2,r3
000008  4611              MOV      r1,r2
;;;285    	ADC->CR = reg | (cfg->u32Src) | (cfg->u8Cnt) | ADC_CR_TMTRGMOD;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  7903              LDRB     r3,[r0,#4]
000010  431a              ORRS     r2,r2,r3
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  431a              ORRS     r2,r2,r3
000018  4b01              LDR      r3,|L12.32|
00001a  609a              STR      r2,[r3,#8]
;;;286    
;;;287    }
00001c  4770              BX       lr
;;;288    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      0x400e0040
                  |L12.36|
                          DCD      0x00ffcffe

                          AREA ||i.ADC_GetConversionData||, CODE, READONLY, ALIGN=2

                  ADC_GetConversionData PROC
;;;186      */
;;;187    int32_t ADC_GetConversionData(uint8_t u8Ch)
000000  4601              MOV      r1,r0
;;;188    {
;;;189            return(*(__IO uint32_t *)(ADC_BASE + (u8Ch * 4)) & ADC_RESULT_RSLT_MASK);
000002  0088              LSLS     r0,r1,#2
000004  4a02              LDR      r2,|L13.16|
000006  1880              ADDS     r0,r0,r2
000008  6800              LDR      r0,[r0,#0]
00000a  0500              LSLS     r0,r0,#20
00000c  0d00              LSRS     r0,r0,#20
;;;190    }
00000e  4770              BX       lr
;;;191    
                          ENDP

                  |L13.16|
                          DCD      0x400e0000

                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;37       */
;;;38     void ADC_Init(uint32_t u32InputMode, uint32_t u32OpMode, uint32_t u32Mask, uint32_t u32Ref)
000000  b530              PUSH     {r4,r5,lr}
;;;39     {
;;;40             assert_param(u32Mask < (1 << ADC_CH_NUM));
;;;41             assert_param((u32InputMode == ADC_CR_DIFF) || (u32InputMode == ADC_CR_SINGLE_END));
;;;42     	assert_param((u32OpMode == ADC_CR_ADMD_SINGEL) ||
;;;43                          (u32OpMode == ADC_CR_ADMD_S_CYCLE) ||
;;;44                          (u32OpMode == ADC_CR_ADMD_CONTINUOUS));
;;;45             assert_param((u32Ref == ADC_CR_REFSEL_AVDD) ||
;;;46     		(u32Ref == ADC_CR_REFSEL_INT_REF) ||
;;;47     		(u32Ref == ADC_CR_REFSEL_VREF));
;;;48     
;;;49             /* ADC engine clock enable */
;;;50             CLK->APBCLK |= CLK_APBCLK_ADC_EN;
000002  4c09              LDR      r4,|L14.40|
000004  68a4              LDR      r4,[r4,#8]
000006  2501              MOVS     r5,#1
000008  072d              LSLS     r5,r5,#28
00000a  432c              ORRS     r4,r4,r5
00000c  4d06              LDR      r5,|L14.40|
00000e  60ac              STR      r4,[r5,#8]
;;;51     	ADC->CR = u32InputMode | u32OpMode | u32Ref | ADC_CR_RESSEL_12BIT;
000010  4604              MOV      r4,r0
000012  430c              ORRS     r4,r4,r1
000014  431c              ORRS     r4,r4,r3
000016  2503              MOVS     r5,#3
000018  04ad              LSLS     r5,r5,#18
00001a  432c              ORRS     r4,r4,r5
00001c  4d03              LDR      r5,|L14.44|
00001e  60ac              STR      r4,[r5,#8]
;;;52             ADC->CHER = u32Mask;
000020  462c              MOV      r4,r5
000022  60e2              STR      r2,[r4,#0xc]
;;;53     
;;;54     }
000024  bd30              POP      {r4,r5,pc}
;;;55     
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x50000200
                  |L14.44|
                          DCD      0x400e0040

                          AREA ||i.ADC_IsDataOverrun||, CODE, READONLY, ALIGN=2

                  ADC_IsDataOverrun PROC
;;;212      */
;;;213    uint32_t ADC_IsDataOverrun(uint8_t u8Ch)
000000  4601              MOV      r1,r0
;;;214    {
;;;215            assert_param(u8Ch < ADC_CH_NUM);
;;;216    
;;;217            return((*(__IO uint32_t *)(ADC_BASE + (u8Ch * 4)) & ADC_RESULT_OVERRUN) ? 1 : 0);
000002  0088              LSLS     r0,r1,#2
000004  4a03              LDR      r2,|L15.20|
000006  1880              ADDS     r0,r0,r2
000008  6800              LDR      r0,[r0,#0]
00000a  2201              MOVS     r2,#1
00000c  0452              LSLS     r2,r2,#17
00000e  4010              ANDS     r0,r0,r2
000010  0c40              LSRS     r0,r0,#17
;;;218    }
000012  4770              BX       lr
;;;219    
                          ENDP

                  |L15.20|
                          DCD      0x400e0000

                          AREA ||i.ADC_IsDataValid||, CODE, READONLY, ALIGN=2

                  ADC_IsDataValid PROC
;;;198      */
;;;199    uint32_t ADC_IsDataValid(uint8_t u8Ch)
000000  4601              MOV      r1,r0
;;;200    {
;;;201            assert_param(u8Ch < ADC_CH_NUM);
;;;202    
;;;203            return((*(__IO uint32_t *)(ADC_BASE + (u8Ch * 4)) & ADC_RESULT_VALID) ? 1 : 0);
000002  0088              LSLS     r0,r1,#2
000004  4a03              LDR      r2,|L16.20|
000006  1880              ADDS     r0,r0,r2
000008  6800              LDR      r0,[r0,#0]
00000a  2201              MOVS     r2,#1
00000c  0412              LSLS     r2,r2,#16
00000e  4010              ANDS     r0,r0,r2
000010  0c00              LSRS     r0,r0,#16
;;;204    }
000012  4770              BX       lr
;;;205    
                          ENDP

                  |L16.20|
                          DCD      0x400e0000

                          AREA ||i.ADC_SetPDMode||, CODE, READONLY, ALIGN=2

                  ADC_SetPDMode PROC
;;;319      */
;;;320    void ADC_SetPDMode(uint32_t u32PdMode, uint32_t u32CalEn)
000000  b510              PUSH     {r4,lr}
;;;321    {
;;;322    	uint32_t reg;
;;;323    
;;;324    	assert_param((u32PdMode == ADC_PWRCTL_PWDMOD_PD) || (u32PdMode == ADC_PWRCTL_PWDMOD_STBY));
;;;325    	assert_param((u32CalEn == ADC_PWRCTL_PWDCALEN) || (u32CalEn == ADC_PWRCTL_PWDCALDIS));
;;;326    
;;;327    	reg = ADC->PWRCTL & ~(ADC_PWRCTL_PWDCALEN | ADC_PWRCTL_PWDMOD_STBY);
000002  4b05              LDR      r3,|L17.24|
000004  6a5b              LDR      r3,[r3,#0x24]
000006  240a              MOVS     r4,#0xa
000008  43a3              BICS     r3,r3,r4
00000a  461a              MOV      r2,r3
;;;328    	ADC->PWRCTL = reg | u32PdMode | u32CalEn;
00000c  4613              MOV      r3,r2
00000e  4303              ORRS     r3,r3,r0
000010  430b              ORRS     r3,r3,r1
000012  4c01              LDR      r4,|L17.24|
000014  6263              STR      r3,[r4,#0x24]
;;;329    
;;;330    }
000016  bd10              POP      {r4,pc}
;;;331    
                          ENDP

                  |L17.24|
                          DCD      0x400e0040

                          AREA ||i.ADC_SetResolution||, CODE, READONLY, ALIGN=2

                  ADC_SetResolution PROC
;;;336      */
;;;337    void ADC_SetResolution(uint32_t u32Res)
000000  4904              LDR      r1,|L18.20|
;;;338    {
;;;339            assert_param((u32Res == ADC_CR_RESSEL_6BIT) ||
;;;340                         (u32Res == ADC_CR_RESSEL_8BIT) ||
;;;341                         (u32Res == ADC_CR_RESSEL_10BIT) ||
;;;342                         (u32Res == ADC_CR_RESSEL_12BIT));
;;;343            ADC->CR = (ADC->CR & ~ADC_CR_RESSEL_MASK) | u32Res;
000002  6889              LDR      r1,[r1,#8]
000004  2203              MOVS     r2,#3
000006  0492              LSLS     r2,r2,#18
000008  4391              BICS     r1,r1,r2
00000a  4301              ORRS     r1,r1,r0
00000c  4a01              LDR      r2,|L18.20|
00000e  6091              STR      r1,[r2,#8]
;;;344    
;;;345    }
000010  4770              BX       lr
;;;346    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x400e0040

                          AREA ||i.ADC_SetSampleTime||, CODE, READONLY, ALIGN=2

                  ADC_SetSampleTime PROC
;;;353      */
;;;354    void ADC_SetSampleTime(uint8_t u8Ch, uint32_t u32Time)
000000  b530              PUSH     {r4,r5,lr}
;;;355    {
000002  460a              MOV      r2,r1
;;;356            uint32_t reg;
;;;357    
;;;358            assert_param(u8Ch < ADC_CH_NUM);
;;;359            assert_param(u32Time < ADC_SMPLCNT_Mask);
;;;360    
;;;361            if(u8Ch< 8) {
000004  2808              CMP      r0,#8
000006  da0c              BGE      |L19.34|
;;;362                    reg = ADC->SMPLCNT0 & ~(0xF << (4 *u8Ch));
000008  4b14              LDR      r3,|L19.92|
00000a  6b19              LDR      r1,[r3,#0x30]
00000c  0085              LSLS     r5,r0,#2
00000e  240f              MOVS     r4,#0xf
000010  40ac              LSLS     r4,r4,r5
000012  43a1              BICS     r1,r1,r4
;;;363                    ADC->SMPLCNT0 = reg | (u32Time << (4 * u8Ch));
000014  0084              LSLS     r4,r0,#2
000016  4613              MOV      r3,r2
000018  40a3              LSLS     r3,r3,r4
00001a  430b              ORRS     r3,r3,r1
00001c  4c0f              LDR      r4,|L19.92|
00001e  6323              STR      r3,[r4,#0x30]
000020  e01b              B        |L19.90|
                  |L19.34|
;;;364            } else if(u8Ch < 12) {
000022  280c              CMP      r0,#0xc
000024  da10              BGE      |L19.72|
;;;365                    reg = ADC->SMPLCNT1 & ~(0xF << (4 * (u8Ch - 8)));
000026  4b0d              LDR      r3,|L19.92|
000028  6b59              LDR      r1,[r3,#0x34]
00002a  4604              MOV      r4,r0
00002c  3c08              SUBS     r4,r4,#8
00002e  00a5              LSLS     r5,r4,#2
000030  240f              MOVS     r4,#0xf
000032  40ac              LSLS     r4,r4,r5
000034  43a1              BICS     r1,r1,r4
;;;366                    ADC->SMPLCNT1 = reg | (u32Time << (4 * (u8Ch - 8)));
000036  4603              MOV      r3,r0
000038  3b08              SUBS     r3,r3,#8
00003a  009c              LSLS     r4,r3,#2
00003c  4613              MOV      r3,r2
00003e  40a3              LSLS     r3,r3,r4
000040  430b              ORRS     r3,r3,r1
000042  4c06              LDR      r4,|L19.92|
000044  6363              STR      r3,[r4,#0x34]
000046  e008              B        |L19.90|
                  |L19.72|
;;;367            } else {  // internal channel
;;;368                    reg = ADC->SMPLCNT1 & ~(0xF << (4 * (13 - 8)));
000048  4b04              LDR      r3,|L19.92|
00004a  6b59              LDR      r1,[r3,#0x34]
00004c  240f              MOVS     r4,#0xf
00004e  0524              LSLS     r4,r4,#20
000050  43a1              BICS     r1,r1,r4
;;;369                    ADC->SMPLCNT1 = reg | (u32Time << (4 * (13 - 8)));
000052  0513              LSLS     r3,r2,#20
000054  430b              ORRS     r3,r3,r1
000056  4c01              LDR      r4,|L19.92|
000058  6363              STR      r3,[r4,#0x34]
                  |L19.90|
;;;370            }
;;;371    
;;;372    }
00005a  bd30              POP      {r4,r5,pc}
;;;373    
                          ENDP

                  |L19.92|
                          DCD      0x400e0040

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;809     */
;;;810    static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;811    {
;;;812      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L20.16|
00000a  6011              STR      r1,[r2,#0]
;;;813    }
00000c  4770              BX       lr
;;;814    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;796     */
;;;797    static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;798    {
;;;799      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L21.16|
00000a  6011              STR      r1,[r2,#0]
;;;800    }
00000c  4770              BX       lr
;;;801    
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0xe000e100
