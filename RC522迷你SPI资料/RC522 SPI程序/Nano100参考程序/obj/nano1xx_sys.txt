; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\obj\nano1xx_sys.o --depend=.\obj\nano1xx_sys.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\Nuvoton -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\nano1xx_sys.crf Libraries\nano1xx_sys.c]
                          THUMB

                          AREA ||i.SYS_Delay||, CODE, READONLY, ALIGN=2

                  SYS_Delay PROC
;;;243      */
;;;244    void SYS_Delay(uint32_t us)
000000  b510              PUSH     {r4,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246    	SysTick->LOAD = (us * ((SystemCoreClock + 500000) / 1000000));
000004  490a              LDR      r1,|L1.48|
000006  480b              LDR      r0,|L1.52|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  104a              ASRS     r2,r1,#1
00000c  1880              ADDS     r0,r0,r2
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  4360              MULS     r0,r4,r0
000014  4908              LDR      r1,|L1.56|
000016  6148              STR      r0,[r1,#0x14]
;;;247    	SysTick->VAL  = (0x00);
000018  2000              MOVS     r0,#0
00001a  6188              STR      r0,[r1,#0x18]
;;;248        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00001c  2005              MOVS     r0,#5
00001e  6108              STR      r0,[r1,#0x10]
;;;249    
;;;250        /* Waiting for down-count to zero */
;;;251        while((SysTick->CTRL & (1 << 16)) == 0);
000020  bf00              NOP      
                  |L1.34|
000022  4805              LDR      r0,|L1.56|
000024  6900              LDR      r0,[r0,#0x10]
000026  2101              MOVS     r1,#1
000028  0409              LSLS     r1,r1,#16
00002a  4208              TST      r0,r1
00002c  d0f9              BEQ      |L1.34|
;;;252    
;;;253    }
00002e  bd10              POP      {r4,pc}
;;;254    
                          ENDP

                  |L1.48|
                          DCD      0x000f4240
                  |L1.52|
                          DCD      SystemCoreClock
                  |L1.56|
                          DCD      0xe000e000

                          AREA ||i.SYS_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  SYS_GetHCLKFreq PROC
;;;130      */
;;;131    uint32_t SYS_GetHCLKFreq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;132    {
;;;133    	
;;;134    	uint32_t u32Freqout, u32AHBDivider, u32ClkSel;
;;;135    
;;;136    	u32ClkSel = CLK->CLKSEL0 & CLK_CLKSEL0_HCLK_MASK;
000002  4810              LDR      r0,|L2.68|
000004  6900              LDR      r0,[r0,#0x10]
000006  0745              LSLS     r5,r0,#29
000008  0f6d              LSRS     r5,r5,#29
;;;137    
;;;138    	if (u32ClkSel == CLK_CLKSEL0_HCLK_HXT)	/* external HXT crystal clock */
00000a  2d00              CMP      r5,#0
00000c  d101              BNE      |L2.18|
;;;139    	{
;;;140    		u32Freqout = __XTAL;	
00000e  4c0e              LDR      r4,|L2.72|
000010  e00e              B        |L2.48|
                  |L2.18|
;;;141    	}
;;;142    	else if(u32ClkSel == CLK_CLKSEL0_HCLK_LXT)		/* external LXT crystal clock */ 
000012  2d01              CMP      r5,#1
000014  d101              BNE      |L2.26|
;;;143    	{
;;;144    		u32Freqout = __RTC_XTAL;
000016  03ec              LSLS     r4,r5,#15
000018  e00a              B        |L2.48|
                  |L2.26|
;;;145    	}
;;;146    	else if(u32ClkSel == CLK_CLKSEL0_HCLK_PLL)		/* PLL clock */
00001a  2d02              CMP      r5,#2
00001c  d103              BNE      |L2.38|
;;;147    	{
;;;148    		u32Freqout = SYS_GetPLLClockFreq();
00001e  f7fffffe          BL       SYS_GetPLLClockFreq
000022  4604              MOV      r4,r0
000024  e004              B        |L2.48|
                  |L2.38|
;;;149    	}
;;;150    	else if(u32ClkSel == CLK_CLKSEL0_HCLK_LIRC)	/* internal LIRC oscillator clock */
000026  2d03              CMP      r5,#3
000028  d101              BNE      |L2.46|
;;;151    	{
;;;152    	 	u32Freqout = __IRC10K;
00002a  4c08              LDR      r4,|L2.76|
00002c  e000              B        |L2.48|
                  |L2.46|
;;;153    	}
;;;154    	else									/* internal HIRC oscillator clock */
;;;155    	{
;;;156    	 	u32Freqout = __IRC12M;
00002e  4c06              LDR      r4,|L2.72|
                  |L2.48|
;;;157    	
;;;158    	}
;;;159    	u32AHBDivider = (CLK->CLKDIV0 & CLK_CLKDIV0_HCLK_MASK) + 1 ;
000030  4804              LDR      r0,|L2.68|
000032  69c0              LDR      r0,[r0,#0x1c]
000034  0700              LSLS     r0,r0,#28
000036  0f00              LSRS     r0,r0,#28
000038  1c46              ADDS     r6,r0,#1
;;;160    	
;;;161    	return (u32Freqout/u32AHBDivider);	
00003a  4631              MOV      r1,r6
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_uidivmod
;;;162    }
000042  bd70              POP      {r4-r6,pc}
;;;163    
                          ENDP

                  |L2.68|
                          DCD      0x50000200
                  |L2.72|
                          DCD      0x00b71b00
                  |L2.76|
                          DCD      0x00002710

                          AREA ||i.SYS_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  SYS_GetPLLClockFreq PROC
;;;92       */
;;;93     uint32_t SYS_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;94     {
;;;95     	uint32_t u32Freq =0, u32PLLSrc;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;96         uint32_t u32NO, u32NR, u32IN_DV, u32PllReg;
;;;97     
;;;98     	u32PllReg = CLK->PLLCTL;
000006  481b              LDR      r0,|L3.116|
000008  6a45              LDR      r5,[r0,#0x24]
;;;99     
;;;100    	if (u32PllReg & CLK_PLLCTL_PD)  
00000a  01c0              LSLS     r0,r0,#7
00000c  4205              TST      r5,r0
00000e  d001              BEQ      |L3.20|
;;;101    		return 0;	 /* PLL is in power down mode */
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;102    	
;;;103    	if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;104    		u32PLLSrc = __IRC12M;
;;;105    	else
;;;106    		u32PLLSrc = __XTAL;
;;;107    
;;;108        u32NO = (u32PllReg & CLK_PLLCTL_OUT_DV) ? 2: 1;
;;;109    
;;;110    	u32IN_DV = (u32PllReg & CLK_PLLCTL_IN_DIVIDER_MASK) >> 8;
;;;111    	if (u32IN_DV == 0)
;;;112    		u32NR = 2;
;;;113    	else if (u32IN_DV == 1)
;;;114    		u32NR = 4;
;;;115    	else if (u32IN_DV == 2)
;;;116    		u32NR = 8;
;;;117    	else
;;;118    		u32NR = 16;
;;;119    
;;;120    	u32Freq = u32PLLSrc * ((u32PllReg & CLK_PLLCTL_FB_DIVIDER_MASK) +32) / u32NR / u32NO;
;;;121    
;;;122    	return u32Freq;
;;;123    }
000012  bdfe              POP      {r1-r7,pc}
                  |L3.20|
000014  2001              MOVS     r0,#1                 ;103
000016  0440              LSLS     r0,r0,#17             ;103
000018  4205              TST      r5,r0                 ;103
00001a  d001              BEQ      |L3.32|
00001c  4f16              LDR      r7,|L3.120|
00001e  e000              B        |L3.34|
                  |L3.32|
000020  4f15              LDR      r7,|L3.120|
                  |L3.34|
000022  2001              MOVS     r0,#1                 ;108
000024  0300              LSLS     r0,r0,#12             ;108
000026  4205              TST      r5,r0                 ;108
000028  d001              BEQ      |L3.46|
00002a  2002              MOVS     r0,#2                 ;108
00002c  e000              B        |L3.48|
                  |L3.46|
00002e  2001              MOVS     r0,#1                 ;108
                  |L3.48|
000030  9001              STR      r0,[sp,#4]            ;108
000032  2003              MOVS     r0,#3                 ;110
000034  0200              LSLS     r0,r0,#8              ;110
000036  4028              ANDS     r0,r0,r5              ;110
000038  0a06              LSRS     r6,r0,#8              ;110
00003a  2e00              CMP      r6,#0                 ;111
00003c  d101              BNE      |L3.66|
00003e  2402              MOVS     r4,#2                 ;112
000040  e008              B        |L3.84|
                  |L3.66|
000042  2e01              CMP      r6,#1                 ;113
000044  d101              BNE      |L3.74|
000046  2404              MOVS     r4,#4                 ;114
000048  e004              B        |L3.84|
                  |L3.74|
00004a  2e02              CMP      r6,#2                 ;115
00004c  d101              BNE      |L3.82|
00004e  2408              MOVS     r4,#8                 ;116
000050  e000              B        |L3.84|
                  |L3.82|
000052  2410              MOVS     r4,#0x10              ;118
                  |L3.84|
000054  06a9              LSLS     r1,r5,#26             ;120
000056  0e89              LSRS     r1,r1,#26             ;120
000058  3120              ADDS     r1,r1,#0x20           ;120
00005a  4379              MULS     r1,r7,r1              ;120
00005c  4608              MOV      r0,r1                 ;120
00005e  4621              MOV      r1,r4                 ;120
000060  f7fffffe          BL       __aeabi_uidivmod
000064  9000              STR      r0,[sp,#0]            ;120
000066  9901              LDR      r1,[sp,#4]            ;120
000068  f7fffffe          BL       __aeabi_uidivmod
00006c  9002              STR      r0,[sp,#8]            ;120
00006e  9802              LDR      r0,[sp,#8]            ;122
000070  e7cf              B        |L3.18|
;;;124    
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      0x50000200
                  |L3.120|
                          DCD      0x00b71b00

                          AREA ||i.SYS_InitChipClock||, CODE, READONLY, ALIGN=2

                  SYS_InitChipClock PROC
;;;182      */
;;;183    int32_t SYS_InitChipClock(S_SYS_CHIP_CLKCFG *sChipCfg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185    	uint32_t u32ClkEn, u32ClkSts, u32PllCtl;	
;;;186    	volatile uint32_t delayCnt;
;;;187    	
;;;188    	assert_param(CHECK_CLK_CONFIG(sChipCfg));               /* Check input parameter */
;;;189    	assert_param(CHECK_HCLK_SOURCE(sChipCfg->u32HClkSrc));  /* Check HCLK clock select */
;;;190    
;;;191    	/* enable chip clock sources */
;;;192    	u32ClkEn = u32ClkSts = (sChipCfg->u32ChipClkEn) & 0x0F; 
000004  6820              LDR      r0,[r4,#0]
000006  0700              LSLS     r0,r0,#28
000008  0f00              LSRS     r0,r0,#28
00000a  4606              MOV      r6,r0
00000c  9000              STR      r0,[sp,#0]
;;;193    	if (u32ClkSts & CLK_PWRCTL_HIRC_EN) 
00000e  2004              MOVS     r0,#4
000010  4206              TST      r6,r0
000012  d005              BEQ      |L4.32|
;;;194    		u32ClkSts = (u32ClkSts & ~CLK_PWRCTL_HIRC_EN) | CLK_CLKSTATUS_HIRC_STB;
000014  4630              MOV      r0,r6
000016  2104              MOVS     r1,#4
000018  4388              BICS     r0,r0,r1
00001a  2110              MOVS     r1,#0x10
00001c  4308              ORRS     r0,r0,r1
00001e  4606              MOV      r6,r0
                  |L4.32|
;;;195    	
;;;196    	SYS_SetChipClockSrc(u32ClkEn, 1);  /* enable the selected chip clock sources */
000020  bf00              NOP      
000022  2001              MOVS     r0,#1
000024  2801              CMP      r0,#1
000026  d106              BNE      |L4.54|
000028  482a              LDR      r0,|L4.212|
00002a  6800              LDR      r0,[r0,#0]
00002c  9900              LDR      r1,[sp,#0]
00002e  4308              ORRS     r0,r0,r1
000030  4928              LDR      r1,|L4.212|
000032  6008              STR      r0,[r1,#0]
000034  e005              B        |L4.66|
                  |L4.54|
000036  4827              LDR      r0,|L4.212|
000038  6801              LDR      r1,[r0,#0]
00003a  9800              LDR      r0,[sp,#0]
00003c  4381              BICS     r1,r1,r0
00003e  4825              LDR      r0,|L4.212|
000040  6001              STR      r1,[r0,#0]
                  |L4.66|
000042  bf00              NOP      
;;;197    	
;;;198    	for (delayCnt=0; delayCnt<100000; delayCnt++)
000044  2500              MOVS     r5,#0
000046  e006              B        |L4.86|
                  |L4.72|
;;;199    		if ((CLK->CLKSTATUS & u32ClkSts) == u32ClkSts)
000048  4822              LDR      r0,|L4.212|
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  4030              ANDS     r0,r0,r6
00004e  42b0              CMP      r0,r6
000050  d100              BNE      |L4.84|
;;;200    			break;
000052  e003              B        |L4.92|
                  |L4.84|
000054  1c6d              ADDS     r5,r5,#1              ;198
                  |L4.86|
000056  4820              LDR      r0,|L4.216|
000058  4285              CMP      r5,r0                 ;198
00005a  d3f5              BCC      |L4.72|
                  |L4.92|
00005c  bf00              NOP      
;;;201    
;;;202    	if (delayCnt == 100000)
00005e  481e              LDR      r0,|L4.216|
000060  4285              CMP      r5,r0
000062  d102              BNE      |L4.106|
;;;203    		return -1;
000064  2000              MOVS     r0,#0
000066  43c0              MVNS     r0,r0
                  |L4.104|
;;;204    
;;;205    	/* enable PLL */
;;;206    	if (sChipCfg->u8PLLEnable == 1)  {
;;;207    
;;;208    		/* check PLL in clock freq. */
;;;209    		assert_param(CHECK_PLLIN_CLK(sChipCfg->ePLLInFreq));
;;;210    		assert_param(CHECK_PLLOUT_CLK(sChipCfg->ePLLOutFreq));
;;;211    		
;;;212    		u32PllCtl = _DrvSYS_PLL_Table[sChipCfg->ePLLInFreq][sChipCfg->ePLLOutFreq];
;;;213    
;;;214    		if (u32PllCtl == PLL_NOT_SUPPORTED)
;;;215    			return -2;
;;;216    
;;;217    		/* select correct pll clock source */
;;;218    		u32PllCtl |= sChipCfg->u32PLLClkSrc;
;;;219    
;;;220    		/* set PLL control reg and waits for PLL clock stable */
;;;221    		CLK->PLLCTL = u32PllCtl;
;;;222    
;;;223    		for (delayCnt=0; delayCnt<100000; delayCnt++)
;;;224    			if (CLK->CLKSTATUS & CLK_CLKSTATUS_PLL_STB)
;;;225    				break;
;;;226    
;;;227    		if (delayCnt == 100000)
;;;228    			return -3;		
;;;229    	}
;;;230    
;;;231    	/* set HCLK divider and source */
;;;232    	CLK->CLKDIV0 = (CLK->CLKDIV0 & ~CLK_CLKDIV0_HCLK_MASK) | sChipCfg->u32HClkDiv;
;;;233    	SYS_SelectHCLKSource(sChipCfg->u32HClkSrc); /* select required clock source for HCLk */
;;;234    
;;;235    	return 0;
;;;236    }
000068  bdf8              POP      {r3-r7,pc}
                  |L4.106|
00006a  7a20              LDRB     r0,[r4,#8]            ;206
00006c  2801              CMP      r0,#1                 ;206
00006e  d124              BNE      |L4.186|
000070  7a60              LDRB     r0,[r4,#9]            ;212
000072  210c              MOVS     r1,#0xc               ;212
000074  4348              MULS     r0,r1,r0              ;212
000076  4919              LDR      r1,|L4.220|
000078  1840              ADDS     r0,r0,r1              ;212
00007a  7aa1              LDRB     r1,[r4,#0xa]          ;212
00007c  0049              LSLS     r1,r1,#1              ;212
00007e  5a47              LDRH     r7,[r0,r1]            ;212
000080  4817              LDR      r0,|L4.224|
000082  4287              CMP      r7,r0                 ;214
000084  d102              BNE      |L4.140|
000086  2001              MOVS     r0,#1                 ;215
000088  43c0              MVNS     r0,r0                 ;215
00008a  e7ed              B        |L4.104|
                  |L4.140|
00008c  6860              LDR      r0,[r4,#4]            ;218
00008e  4307              ORRS     r7,r7,r0              ;218
000090  4810              LDR      r0,|L4.212|
000092  6247              STR      r7,[r0,#0x24]         ;221
000094  2500              MOVS     r5,#0                 ;223
000096  e006              B        |L4.166|
                  |L4.152|
000098  480e              LDR      r0,|L4.212|
00009a  68c0              LDR      r0,[r0,#0xc]          ;224
00009c  2104              MOVS     r1,#4                 ;224
00009e  4208              TST      r0,r1                 ;224
0000a0  d000              BEQ      |L4.164|
0000a2  e003              B        |L4.172|
                  |L4.164|
0000a4  1c6d              ADDS     r5,r5,#1              ;223
                  |L4.166|
0000a6  480c              LDR      r0,|L4.216|
0000a8  4285              CMP      r5,r0                 ;223
0000aa  d3f5              BCC      |L4.152|
                  |L4.172|
0000ac  bf00              NOP                            ;225
0000ae  480a              LDR      r0,|L4.216|
0000b0  4285              CMP      r5,r0                 ;227
0000b2  d102              BNE      |L4.186|
0000b4  2002              MOVS     r0,#2                 ;228
0000b6  43c0              MVNS     r0,r0                 ;228
0000b8  e7d6              B        |L4.104|
                  |L4.186|
0000ba  4806              LDR      r0,|L4.212|
0000bc  69c0              LDR      r0,[r0,#0x1c]         ;232
0000be  0900              LSRS     r0,r0,#4              ;232
0000c0  0100              LSLS     r0,r0,#4              ;232
0000c2  6921              LDR      r1,[r4,#0x10]         ;232
0000c4  4308              ORRS     r0,r0,r1              ;232
0000c6  4903              LDR      r1,|L4.212|
0000c8  61c8              STR      r0,[r1,#0x1c]         ;232
0000ca  68e0              LDR      r0,[r4,#0xc]          ;233
0000cc  f7fffffe          BL       SYS_SelectHCLKSource
0000d0  2000              MOVS     r0,#0                 ;235
0000d2  e7c9              B        |L4.104|
;;;237    
                          ENDP

                  |L4.212|
                          DCD      0x50000200
                  |L4.216|
                          DCD      0x000186a0
                  |L4.220|
                          DCD      _DrvSYS_PLL_Table
                  |L4.224|
                          DCD      0x0000ffff

                          AREA ||i.SYS_SelectHCLKSource||, CODE, READONLY, ALIGN=2

                  SYS_SelectHCLKSource PROC
;;;52       */
;;;53     int32_t SYS_SelectHCLKSource(uint32_t u32ClkSrc)
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55     	
;;;56     	CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLK_MASK) | u32ClkSrc;
000004  480b              LDR      r0,|L5.52|
000006  6900              LDR      r0,[r0,#0x10]
000008  08c0              LSRS     r0,r0,#3
00000a  00c0              LSLS     r0,r0,#3
00000c  4320              ORRS     r0,r0,r4
00000e  4909              LDR      r1,|L5.52|
000010  6108              STR      r0,[r1,#0x10]
;;;57     
;;;58     	if (CLK->CLKSTATUS & CLK_CLKSTATUS_CLK_SW_FAIL)  {
000012  4608              MOV      r0,r1
000014  68c0              LDR      r0,[r0,#0xc]
000016  2180              MOVS     r1,#0x80
000018  4208              TST      r0,r1
00001a  d007              BEQ      |L5.44|
;;;59     		CLK->CLKSTATUS |= CLK_CLKSTATUS_CLK_SW_FAIL;   /* Clear Clock Switch Fail Flag */
00001c  4805              LDR      r0,|L5.52|
00001e  68c0              LDR      r0,[r0,#0xc]
000020  4308              ORRS     r0,r0,r1
000022  4904              LDR      r1,|L5.52|
000024  60c8              STR      r0,[r1,#0xc]
;;;60             return -1;  /* HCLK isn't changed */
000026  2000              MOVS     r0,#0
000028  43c0              MVNS     r0,r0
                  |L5.42|
;;;61         }
;;;62     		
;;;63     	SystemCoreClockUpdate(); /* HCLK is changed successfully */
;;;64     	
;;;65     	return 0;
;;;66     }
00002a  bd10              POP      {r4,pc}
                  |L5.44|
00002c  f7fffffe          BL       SystemCoreClockUpdate
000030  2000              MOVS     r0,#0                 ;65
000032  e7fa              B        |L5.42|
;;;67     
                          ENDP

                  |L5.52|
                          DCD      0x50000200

                          AREA ||i.SYS_SetUpPowerDown||, CODE, READONLY, ALIGN=2

                  SYS_SetUpPowerDown PROC
;;;73       */
;;;74     void SYS_SetUpPowerDown(uint32_t u32Enable)
000000  490e              LDR      r1,|L6.60|
;;;75     {	
;;;76     
;;;77     	CLK->PWRCTL |= (CLK_PWRCTL_PWRDOWN_EN);	   /* Set power down bit */
000002  6809              LDR      r1,[r1,#0]
000004  2240              MOVS     r2,#0x40
000006  4311              ORRS     r1,r1,r2
000008  4a0c              LDR      r2,|L6.60|
00000a  6011              STR      r1,[r2,#0]
;;;78     	SCB->SCR |= 0x04;						   /* Sleep Deep */
00000c  490c              LDR      r1,|L6.64|
00000e  6909              LDR      r1,[r1,#0x10]
000010  2204              MOVS     r2,#4
000012  4311              ORRS     r1,r1,r2
000014  4a0a              LDR      r2,|L6.64|
000016  6111              STR      r1,[r2,#0x10]
;;;79     
;;;80     	if (u32Enable)  {
000018  2800              CMP      r0,#0
00001a  d00d              BEQ      |L6.56|
;;;81     		CLK->PWRCTL |= CLK_PWRCTL_WAKEINT_EN;  /* Enable wake up interrupt source */
00001c  4907              LDR      r1,|L6.60|
00001e  6809              LDR      r1,[r1,#0]
000020  2220              MOVS     r2,#0x20
000022  4311              ORRS     r1,r1,r2
000024  4a05              LDR      r2,|L6.60|
000026  6011              STR      r1,[r2,#0]
;;;82     	    NVIC_EnableIRQ(PDWU_IRQn);			   /* Enable IRQ request for PDWU interupt */
000028  bf00              NOP      
00002a  211c              MOVS     r1,#0x1c
00002c  2201              MOVS     r2,#1
00002e  408a              LSLS     r2,r2,r1
000030  4904              LDR      r1,|L6.68|
000032  600a              STR      r2,[r1,#0]
000034  bf00              NOP      
000036  bf00              NOP      
                  |L6.56|
;;;83     	}
;;;84     
;;;85     }
000038  4770              BX       lr
;;;86     
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x50000200
                  |L6.64|
                          DCD      0xe000ed00
                  |L6.68|
                          DCD      0xe000e100

                          AREA ||.data||, DATA, ALIGN=1

                  _DrvSYS_PLL_Table
000000  ffff0110          DCW      0xffff,0x0110
000004  ffff0010          DCW      0xffff,0x0010
000008  001cffff          DCW      0x001c,0xffff
00000c  ffff0210          DCW      0xffff,0x0210
000010  ffff0110          DCW      0xffff,0x0110
000014  ffff0120          DCW      0xffff,0x0120
000018  ffff0200          DCW      0xffff,0x0200
00001c  ffff0100          DCW      0xffff,0x0100
000020  0230ffff          DCW      0x0230,0xffff
000024  0310ffff          DCW      0x0310,0xffff
000028  0210ffff          DCW      0x0210,0xffff
00002c  0220ffff          DCW      0x0220,0xffff
000030  ffff1320          DCW      0xffff,0x1320
000034  ffff0320          DCW      0xffff,0x0320
000038  0330ffff          DCW      0x0330,0xffff
