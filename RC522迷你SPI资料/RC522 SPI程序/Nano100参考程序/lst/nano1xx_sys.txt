; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\nano1xx_sys.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\nano1xx_sys.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\nano1xx_sys.crf Libraries\nano1xx_sys.c]
                          THUMB

                          AREA ||i.SYS_Delay||, CODE, READONLY, ALIGN=2

                  SYS_Delay PROC
;;;243      */
;;;244    void SYS_Delay(uint32_t us)
000000  b510              PUSH     {r4,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246    	SysTick->LOAD = (us * ((SystemCoreClock + 500000) / 1000000));
000004  490a              LDR      r1,|L1.48|
000006  480b              LDR      r0,|L1.52|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  104a              ASRS     r2,r1,#1
00000c  1880              ADDS     r0,r0,r2
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  4360              MULS     r0,r4,r0
000014  4908              LDR      r1,|L1.56|
000016  6148              STR      r0,[r1,#0x14]
;;;247    	SysTick->VAL  = (0x00);
000018  2000              MOVS     r0,#0
00001a  6188              STR      r0,[r1,#0x18]
;;;248        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00001c  2005              MOVS     r0,#5
00001e  6108              STR      r0,[r1,#0x10]
;;;249    
;;;250        /* Waiting for down-count to zero */
;;;251        while((SysTick->CTRL & (1 << 16)) == 0);
000020  bf00              NOP      
                  |L1.34|
000022  4805              LDR      r0,|L1.56|
000024  6900              LDR      r0,[r0,#0x10]
000026  2101              MOVS     r1,#1
000028  0409              LSLS     r1,r1,#16
00002a  4208              TST      r0,r1
00002c  d0f9              BEQ      |L1.34|
;;;252    
;;;253    }
00002e  bd10              POP      {r4,pc}
;;;254    
                          ENDP

                  |L1.48|
                          DCD      0x000f4240
                  |L1.52|
                          DCD      SystemCoreClock
                  |L1.56|
                          DCD      0xe000e000

                          AREA ||i.SYS_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  SYS_GetHCLKFreq PROC
;;;130      */
;;;131    uint32_t SYS_GetHCLKFreq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;132    {
;;;133    	
;;;134    	uint32_t u32Freqout, u32AHBDivider, u32ClkSel;
;;;135    
;;;136    	u32ClkSel = CLK->CLKSEL0 & CLK_CLKSEL0_HCLK_MASK;
000002  4810              LDR      r0,|L2.68|
000004  6900              LDR      r0,[r0,#0x10]
000006  0745              LSLS     r5,r0,#29
000008  0f6d              LSRS     r5,r5,#29
;;;137    
;;;138    	if (u32ClkSel == CLK_CLKSEL0_HCLK_HXT)	/* external HXT crystal clock */
00000a  2d00              CMP      r5,#0
00000c  d101              BNE      |L2.18|
;;;139    	{
;;;140    		u32Freqout = __XTAL;	
00000e  4c0e              LDR      r4,|L2.72|
000010  e00e              B        |L2.48|
                  |L2.18|
;;;141    	}
;;;142    	else if(u32ClkSel == CLK_CLKSEL0_HCLK_LXT)		/* external LXT crystal clock */ 
000012  2d01              CMP      r5,#1
000014  d101              BNE      |L2.26|
;;;143    	{
;;;144    		u32Freqout = __RTC_XTAL;
000016  03ec              LSLS     r4,r5,#15
000018  e00a              B        |L2.48|
                  |L2.26|
;;;145    	}
;;;146    	else if(u32ClkSel == CLK_CLKSEL0_HCLK_PLL)		/* PLL clock */
00001a  2d02              CMP      r5,#2
00001c  d103              BNE      |L2.38|
;;;147    	{
;;;148    		u32Freqout = SYS_GetPLLClockFreq();
00001e  f7fffffe          BL       SYS_GetPLLClockFreq
000022  4604              MOV      r4,r0
000024  e004              B        |L2.48|
                  |L2.38|
;;;149    	}
;;;150    	else if(u32ClkSel == CLK_CLKSEL0_HCLK_LIRC)	/* internal LIRC oscillator clock */
000026  2d03              CMP      r5,#3
000028  d101              BNE      |L2.46|
;;;151    	{
;;;152    	 	u32Freqout = __IRC10K;
00002a  4c08              LDR      r4,|L2.76|
00002c  e000              B        |L2.48|
                  |L2.46|
;;;153    	}
;;;154    	else									/* internal HIRC oscillator clock */
;;;155    	{
;;;156    	 	u32Freqout = __IRC12M;
00002e  4c06              LDR      r4,|L2.72|
                  |L2.48|
;;;157    	
;;;158    	}
;;;159    	u32AHBDivider = (CLK->CLKDIV0 & CLK_CLKDIV0_HCLK_MASK) + 1 ;
000030  4804              LDR      r0,|L2.68|
000032  69c0              LDR      r0,[r0,#0x1c]
000034  0700              LSLS     r0,r0,#28
000036  0f00              LSRS     r0,r0,#28
000038  1c46              ADDS     r6,r0,#1
;;;160    	
;;;161    	return (u32Freqout/u32AHBDivider);	
00003a  4631              MOV      r1,r6
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_uidivmod
;;;162    }
000042  bd70              POP      {r4-r6,pc}
;;;163    
                          ENDP

                  |L2.68|
                          DCD      0x50000200
                  |L2.72|
                          DCD      0x00b71b00
                  |L2.76|
                          DCD      0x00002710

                          AREA ||i.SYS_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  SYS_GetPLLClockFreq PROC
;;;92       */
;;;93     uint32_t SYS_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;94     {
;;;95     	uint32_t u32Freq =0, u32PLLSrc;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;96         uint32_t u32NO, u32NR, u32IN_DV, u32PllReg;
;;;97     
;;;98     	u32PllReg = CLK->PLLCTL;
000006  481b              LDR      r0,|L3.116|
000008  6a45              LDR      r5,[r0,#0x24]
;;;99     
;;;100    	if (u32PllReg & CLK_PLLCTL_PD)  
00000a  01c0              LSLS     r0,r0,#7
00000c  4205              TST      r5,r0
00000e  d001              BEQ      |L3.20|
;;;101    		return 0;	 /* PLL is in power down mode */
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;102    	
;;;103    	if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;104    		u32PLLSrc = __IRC12M;
;;;105    	else
;;;106    		u32PLLSrc = __XTAL;
;;;107    
;;;108        u32NO = (u32PllReg & CLK_PLLCTL_OUT_DV) ? 2: 1;
;;;109    
;;;110    	u32IN_DV = (u32PllReg & CLK_PLLCTL_IN_DIVIDER_MASK) >> 8;
;;;111    	if (u32IN_DV == 0)
;;;112    		u32NR = 2;
;;;113    	else if (u32IN_DV == 1)
;;;114    		u32NR = 4;
;;;115    	else if (u32IN_DV == 2)
;;;116    		u32NR = 8;
;;;117    	else
;;;118    		u32NR = 16;
;;;119    
;;;120    	u32Freq = u32PLLSrc * ((u32PllReg & CLK_PLLCTL_FB_DIVIDER_MASK) +32) / u32NR / u32NO;
;;;121    
;;;122    	return u32Freq;
;;;123    }
000012  bdfe              POP      {r1-r7,pc}
                  |L3.20|
000014  2001              MOVS     r0,#1                 ;103
000016  0440              LSLS     r0,r0,#17             ;103
000018  4205              TST      r5,r0                 ;103
00001a  d001              BEQ      |L3.32|
00001c  4f16              LDR      r7,|L3.120|
00001e  e000              B        |L3.34|
                  |L3.32|
000020  4f15              LDR      r7,|L3.120|
                  |L3.34|
000022  2001              MOVS     r0,#1                 ;108
000024  0300              LSLS     r0,r0,#12             ;108
000026  4205              TST      r5,r0                 ;108
000028  d001              BEQ      |L3.46|
00002a  2002              MOVS     r0,#2                 ;108
00002c  e000              B        |L3.48|
                  |L3.46|
00002e  2001              MOVS     r0,#1                 ;108
                  |L3.48|
000030  9001              STR      r0,[sp,#4]            ;108
000032  2003              MOVS     r0,#3                 ;110
000034  0200              LSLS     r0,r0,#8              ;110
000036  4028              ANDS     r0,r0,r5              ;110
000038  0a06              LSRS     r6,r0,#8              ;110
00003a  2e00              CMP      r6,#0                 ;111
00003c  d101              BNE      |L3.66|
00003e  2402              MOVS     r4,#2                 ;112
000040  e008              B        |L3.84|
                  |L3.66|
000042  2e01              CMP      r6,#1                 ;113
000044  d101              BNE      |L3.74|
000046  2404              MOVS     r4,#4                 ;114
000048  e004              B        |L3.84|
                  |L3.74|
00004a  2e02              CMP      r6,#2                 ;115
00004c  d101              BNE      |L3.82|
00004e  2408              MOVS     r4,#8                 ;116
000050  e000              B        |L3.84|
                  |L3.82|
000052  2410              MOVS     r4,#0x10              ;118
                  |L3.84|
000054  06a9              LSLS     r1,r5,#26             ;120
000056  0e89              LSRS     r1,r1,#26             ;120
000058  3120              ADDS     r1,r1,#0x20           ;120
00005a  4379              MULS     r1,r7,r1              ;120
00005c  4608              MOV      r0,r1                 ;120
00005e  4621              MOV      r1,r4                 ;120
000060  f7fffffe          BL       __aeabi_uidivmod
000064  9000              STR      r0,[sp,#0]            ;120
000066  9901              LDR      r1,[sp,#4]            ;120
000068  f7fffffe          BL       __aeabi_uidivmod
00006c  9002              STR      r0,[sp,#8]            ;120
00006e  9802              LDR      r0,[sp,#8]            ;122
000070  e7cf              B        |L3.18|
;;;124    
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      0x50000200
                  |L3.120|
                          DCD      0x00b71b00

                          AREA ||i.SYS_InitChipClock||, CODE, READONLY, ALIGN=2

                  SYS_InitChipClock PROC
;;;182      */
;;;183    int32_t SYS_InitChipClock(S_SYS_CHIP_CLKCFG *sChipCfg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185    	uint32_t u32ClkEn, u32ClkSts, u32PllCtl;	
;;;186    	volatile uint32_t delayCnt;
;;;187    	
;;;188    	assert_param(CHECK_CLK_CONFIG(sChipCfg));               /* Check input parameter */
;;;189    	assert_param(CHECK_HCLK_SOURCE(sChipCfg->u32HClkSrc));  /* Check HCLK clock select */
;;;190    
;;;191    	/* enable chip clock sources */
;;;192    	u32ClkEn = u32ClkSts = (sChipCfg->u32ChipClkEn) & 0x0F; 
000004  7820              LDRB     r0,[r4,#0]
000006  0700              LSLS     r0,r0,#28
000008  0f00              LSRS     r0,r0,#28
00000a  4605              MOV      r5,r0
00000c  4607              MOV      r7,r0
;;;193    	if (u32ClkSts & CLK_PWRCTL_HIRC_EN) 
00000e  2004              MOVS     r0,#4
000010  4205              TST      r5,r0
000012  d005              BEQ      |L4.32|
;;;194    		u32ClkSts = (u32ClkSts & ~CLK_PWRCTL_HIRC_EN) | CLK_CLKSTATUS_HIRC_STB;
000014  4628              MOV      r0,r5
000016  2104              MOVS     r1,#4
000018  4388              BICS     r0,r0,r1
00001a  2110              MOVS     r1,#0x10
00001c  4308              ORRS     r0,r0,r1
00001e  4605              MOV      r5,r0
                  |L4.32|
;;;195    	
;;;196    	SYS_SetChipClockSrc(u32ClkEn, 1);  /* enable the selected chip clock sources */
000020  4638              MOV      r0,r7
000022  2101              MOVS     r1,#1
000024  2900              CMP      r1,#0
000026  d005              BEQ      |L4.52|
000028  4a2e              LDR      r2,|L4.228|
00002a  6812              LDR      r2,[r2,#0]
00002c  4302              ORRS     r2,r2,r0
00002e  4b2d              LDR      r3,|L4.228|
000030  601a              STR      r2,[r3,#0]
000032  e004              B        |L4.62|
                  |L4.52|
000034  4a2b              LDR      r2,|L4.228|
000036  6812              LDR      r2,[r2,#0]
000038  4382              BICS     r2,r2,r0
00003a  4b2a              LDR      r3,|L4.228|
00003c  601a              STR      r2,[r3,#0]
                  |L4.62|
00003e  bf00              NOP      
;;;197    	
;;;198    	for (delayCnt=0; delayCnt<100000; delayCnt++)
000040  2000              MOVS     r0,#0
000042  9000              STR      r0,[sp,#0]
000044  e008              B        |L4.88|
                  |L4.70|
;;;199    		if ((CLK->CLKSTATUS & u32ClkSts) == u32ClkSts)
000046  4827              LDR      r0,|L4.228|
000048  68c0              LDR      r0,[r0,#0xc]
00004a  4028              ANDS     r0,r0,r5
00004c  42a8              CMP      r0,r5
00004e  d100              BNE      |L4.82|
;;;200    			break;
000050  e006              B        |L4.96|
                  |L4.82|
000052  9800              LDR      r0,[sp,#0]            ;198
000054  1c40              ADDS     r0,r0,#1              ;198
000056  9000              STR      r0,[sp,#0]            ;198
                  |L4.88|
000058  4923              LDR      r1,|L4.232|
00005a  9800              LDR      r0,[sp,#0]            ;198
00005c  4288              CMP      r0,r1                 ;198
00005e  d3f2              BCC      |L4.70|
                  |L4.96|
000060  bf00              NOP      
;;;201    
;;;202    	if (delayCnt == 100000)
000062  4921              LDR      r1,|L4.232|
000064  9800              LDR      r0,[sp,#0]
000066  4288              CMP      r0,r1
000068  d102              BNE      |L4.112|
;;;203    		return -1;
00006a  2000              MOVS     r0,#0
00006c  43c0              MVNS     r0,r0
                  |L4.110|
;;;204    
;;;205    	/* enable PLL */
;;;206    	if (sChipCfg->u8PLLEnable == 1)  {
;;;207    
;;;208    		/* check PLL in clock freq. */
;;;209    		assert_param(CHECK_PLLIN_CLK(sChipCfg->ePLLInFreq));
;;;210    		assert_param(CHECK_PLLOUT_CLK(sChipCfg->ePLLOutFreq));
;;;211    		
;;;212    		u32PllCtl = _DrvSYS_PLL_Table[sChipCfg->ePLLInFreq][sChipCfg->ePLLOutFreq];
;;;213    
;;;214    		if (u32PllCtl == PLL_NOT_SUPPORTED)
;;;215    			return -2;
;;;216    
;;;217    		/* select correct pll clock source */
;;;218    		u32PllCtl |= sChipCfg->u32PLLClkSrc;
;;;219    
;;;220    		/* set PLL control reg and waits for PLL clock stable */
;;;221    		CLK->PLLCTL = u32PllCtl;
;;;222    
;;;223    		for (delayCnt=0; delayCnt<100000; delayCnt++)
;;;224    			if (CLK->CLKSTATUS & CLK_CLKSTATUS_PLL_STB)
;;;225    				break;
;;;226    
;;;227    		if (delayCnt == 100000)
;;;228    			return -3;		
;;;229    	}
;;;230    
;;;231    	/* set HCLK divider and source */
;;;232    	CLK->CLKDIV0 = (CLK->CLKDIV0 & ~CLK_CLKDIV0_HCLK_MASK) | sChipCfg->u32HClkDiv;
;;;233    	SYS_SelectHCLKSource(sChipCfg->u32HClkSrc); /* select required clock source for HCLk */
;;;234    
;;;235    	return 0;
;;;236    }
00006e  bdf8              POP      {r3-r7,pc}
                  |L4.112|
000070  7a20              LDRB     r0,[r4,#8]            ;206
000072  2801              CMP      r0,#1                 ;206
000074  d129              BNE      |L4.202|
000076  7a60              LDRB     r0,[r4,#9]            ;212
000078  210c              MOVS     r1,#0xc               ;212
00007a  4348              MULS     r0,r1,r0              ;212
00007c  491b              LDR      r1,|L4.236|
00007e  1840              ADDS     r0,r0,r1              ;212
000080  7aa1              LDRB     r1,[r4,#0xa]          ;212
000082  0049              LSLS     r1,r1,#1              ;212
000084  5a46              LDRH     r6,[r0,r1]            ;212
000086  481a              LDR      r0,|L4.240|
000088  4286              CMP      r6,r0                 ;214
00008a  d102              BNE      |L4.146|
00008c  2001              MOVS     r0,#1                 ;215
00008e  43c0              MVNS     r0,r0                 ;215
000090  e7ed              B        |L4.110|
                  |L4.146|
000092  6860              LDR      r0,[r4,#4]            ;218
000094  4306              ORRS     r6,r6,r0              ;218
000096  4813              LDR      r0,|L4.228|
000098  6246              STR      r6,[r0,#0x24]         ;221
00009a  2000              MOVS     r0,#0                 ;223
00009c  9000              STR      r0,[sp,#0]            ;223
00009e  e008              B        |L4.178|
                  |L4.160|
0000a0  4810              LDR      r0,|L4.228|
0000a2  68c0              LDR      r0,[r0,#0xc]          ;224
0000a4  2104              MOVS     r1,#4                 ;224
0000a6  4208              TST      r0,r1                 ;224
0000a8  d000              BEQ      |L4.172|
0000aa  e006              B        |L4.186|
                  |L4.172|
0000ac  9800              LDR      r0,[sp,#0]            ;223
0000ae  1c40              ADDS     r0,r0,#1              ;223
0000b0  9000              STR      r0,[sp,#0]            ;223
                  |L4.178|
0000b2  490d              LDR      r1,|L4.232|
0000b4  9800              LDR      r0,[sp,#0]            ;223
0000b6  4288              CMP      r0,r1                 ;223
0000b8  d3f2              BCC      |L4.160|
                  |L4.186|
0000ba  bf00              NOP                            ;225
0000bc  490a              LDR      r1,|L4.232|
0000be  9800              LDR      r0,[sp,#0]            ;227
0000c0  4288              CMP      r0,r1                 ;227
0000c2  d102              BNE      |L4.202|
0000c4  2002              MOVS     r0,#2                 ;228
0000c6  43c0              MVNS     r0,r0                 ;228
0000c8  e7d1              B        |L4.110|
                  |L4.202|
0000ca  4806              LDR      r0,|L4.228|
0000cc  69c0              LDR      r0,[r0,#0x1c]         ;232
0000ce  0900              LSRS     r0,r0,#4              ;232
0000d0  0100              LSLS     r0,r0,#4              ;232
0000d2  6921              LDR      r1,[r4,#0x10]         ;232
0000d4  4308              ORRS     r0,r0,r1              ;232
0000d6  4903              LDR      r1,|L4.228|
0000d8  61c8              STR      r0,[r1,#0x1c]         ;232
0000da  68e0              LDR      r0,[r4,#0xc]          ;233
0000dc  f7fffffe          BL       SYS_SelectHCLKSource
0000e0  2000              MOVS     r0,#0                 ;235
0000e2  e7c4              B        |L4.110|
;;;237    
                          ENDP

                  |L4.228|
                          DCD      0x50000200
                  |L4.232|
                          DCD      0x000186a0
                  |L4.236|
                          DCD      _DrvSYS_PLL_Table
                  |L4.240|
                          DCD      0x0000ffff

                          AREA ||i.SYS_SelectHCLKSource||, CODE, READONLY, ALIGN=2

                  SYS_SelectHCLKSource PROC
;;;52       */
;;;53     int32_t SYS_SelectHCLKSource(uint32_t u32ClkSrc)
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55     	
;;;56     	CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLK_MASK) | u32ClkSrc;
000004  480b              LDR      r0,|L5.52|
000006  6900              LDR      r0,[r0,#0x10]
000008  08c0              LSRS     r0,r0,#3
00000a  00c0              LSLS     r0,r0,#3
00000c  4320              ORRS     r0,r0,r4
00000e  4909              LDR      r1,|L5.52|
000010  6108              STR      r0,[r1,#0x10]
;;;57     
;;;58     	if (CLK->CLKSTATUS & CLK_CLKSTATUS_CLK_SW_FAIL)  {
000012  4608              MOV      r0,r1
000014  68c0              LDR      r0,[r0,#0xc]
000016  2180              MOVS     r1,#0x80
000018  4208              TST      r0,r1
00001a  d007              BEQ      |L5.44|
;;;59     		CLK->CLKSTATUS |= CLK_CLKSTATUS_CLK_SW_FAIL;   /* Clear Clock Switch Fail Flag */
00001c  4805              LDR      r0,|L5.52|
00001e  68c0              LDR      r0,[r0,#0xc]
000020  4308              ORRS     r0,r0,r1
000022  4904              LDR      r1,|L5.52|
000024  60c8              STR      r0,[r1,#0xc]
;;;60             return -1;  /* HCLK isn't changed */
000026  2000              MOVS     r0,#0
000028  43c0              MVNS     r0,r0
                  |L5.42|
;;;61         }
;;;62     		
;;;63     	SystemCoreClockUpdate(); /* HCLK is changed successfully */
;;;64     	
;;;65     	return 0;
;;;66     }
00002a  bd10              POP      {r4,pc}
                  |L5.44|
00002c  f7fffffe          BL       SystemCoreClockUpdate
000030  2000              MOVS     r0,#0                 ;65
000032  e7fa              B        |L5.42|
;;;67     
                          ENDP

                  |L5.52|
                          DCD      0x50000200

                          AREA ||i.SYS_SetUpPowerDown||, CODE, READONLY, ALIGN=2

                  SYS_SetUpPowerDown PROC
;;;73       */
;;;74     void SYS_SetUpPowerDown(uint32_t u32Enable)
000000  4601              MOV      r1,r0
;;;75     {	
;;;76     
;;;77     	CLK->PWRCTL |= (CLK_PWRCTL_PWRDOWN_EN);	   /* Set power down bit */
000002  480e              LDR      r0,|L6.60|
000004  6800              LDR      r0,[r0,#0]
000006  2240              MOVS     r2,#0x40
000008  4310              ORRS     r0,r0,r2
00000a  4a0c              LDR      r2,|L6.60|
00000c  6010              STR      r0,[r2,#0]
;;;78     	SCB->SCR |= 0x04;						   /* Sleep Deep */
00000e  480c              LDR      r0,|L6.64|
000010  6900              LDR      r0,[r0,#0x10]
000012  2204              MOVS     r2,#4
000014  4310              ORRS     r0,r0,r2
000016  4a0a              LDR      r2,|L6.64|
000018  6110              STR      r0,[r2,#0x10]
;;;79     
;;;80     	if (u32Enable)  {
00001a  2900              CMP      r1,#0
00001c  d00c              BEQ      |L6.56|
;;;81     		CLK->PWRCTL |= CLK_PWRCTL_WAKEINT_EN;  /* Enable wake up interrupt source */
00001e  4807              LDR      r0,|L6.60|
000020  6800              LDR      r0,[r0,#0]
000022  2220              MOVS     r2,#0x20
000024  4310              ORRS     r0,r0,r2
000026  4a05              LDR      r2,|L6.60|
000028  6010              STR      r0,[r2,#0]
;;;82     	    NVIC_EnableIRQ(PDWU_IRQn);			   /* Enable IRQ request for PDWU interupt */
00002a  201c              MOVS     r0,#0x1c
00002c  2201              MOVS     r2,#1
00002e  4082              LSLS     r2,r2,r0
000030  4b04              LDR      r3,|L6.68|
000032  601a              STR      r2,[r3,#0]
000034  bf00              NOP      
000036  bf00              NOP      
                  |L6.56|
;;;83     	}
;;;84     
;;;85     }
000038  4770              BX       lr
;;;86     
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x50000200
                  |L6.64|
                          DCD      0xe000ed00
                  |L6.68|
                          DCD      0xe000e100

                          AREA ||.data||, DATA, ALIGN=1

                  _DrvSYS_PLL_Table
000000  ffff0110          DCW      0xffff,0x0110
000004  ffff0010          DCW      0xffff,0x0010
000008  001cffff          DCW      0x001c,0xffff
00000c  ffff0210          DCW      0xffff,0x0210
000010  ffff0110          DCW      0xffff,0x0110
000014  ffff0120          DCW      0xffff,0x0120
000018  ffff0200          DCW      0xffff,0x0200
00001c  ffff0100          DCW      0xffff,0x0100
000020  0230ffff          DCW      0x0230,0xffff
000024  0310ffff          DCW      0x0310,0xffff
000028  0210ffff          DCW      0x0210,0xffff
00002c  0220ffff          DCW      0x0220,0xffff
000030  ffff1320          DCW      0xffff,0x1320
000034  ffff0320          DCW      0xffff,0x0320
000038  0330ffff          DCW      0x0330,0xffff

;*** Start embedded assembler ***

#line 1 "Libraries\\nano1xx_sys.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_nano1xx_sys_c_883593a2____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_nano1xx_sys_c_883593a2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_nano1xx_sys_c_883593a2____REVSH|
#line 144
|__asm___13_nano1xx_sys_c_883593a2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
