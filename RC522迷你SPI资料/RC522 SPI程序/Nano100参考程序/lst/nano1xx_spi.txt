; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\nano1xx_spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\nano1xx_spi.d --feedback=.\obj\START_KIT.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Libraries -I.\Include -I.\Users -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -D__MICROLIB -D__LCDDISPLAY_BTL001_LB_H --omf_browse=.\obj\nano1xx_spi.crf Libraries\nano1xx_spi.c]
                          THUMB

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;526     */
;;;527    __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;528    {
;;;529      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L1.16|
00000a  6011              STR      r1,[r2,#0]
;;;530    }
00000c  4770              BX       lr
;;;531    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;514     */
;;;515    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;516    {
;;;517      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;518    }
00000c  4770              BX       lr
;;;519    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;581     */
;;;582    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;583    {
;;;584      if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da19              BGE      |L3.58|
;;;585        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000006  4a1a              LDR      r2,|L3.112|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L3.112|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L3.108|
                  |L3.58|
;;;586            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;587      else {
;;;588        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L3.116|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L3.116|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L3.108|
;;;589            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;590    }
00006c  bd10              POP      {r4,pc}
;;;591    
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      0xe000ed1c
                  |L3.116|
                          DCD      0xe000e100

                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;172      */  
;;;173    void SPI_Close(SPI_TypeDef *SpiPort)
000000  b510              PUSH     {r4,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175    	if((uint32_t)SpiPort == SPI0_BASE)
000004  480a              LDR      r0,|L4.48|
000006  4284              CMP      r4,r0
000008  d103              BNE      |L4.18|
;;;176    		NVIC_DisableIRQ(SPI0_IRQn);	
00000a  200e              MOVS     r0,#0xe
00000c  f7fffffe          BL       NVIC_DisableIRQ
000010  e00c              B        |L4.44|
                  |L4.18|
;;;177    	else if((uint32_t)SpiPort == SPI1_BASE)
000012  4808              LDR      r0,|L4.52|
000014  4284              CMP      r4,r0
000016  d103              BNE      |L4.32|
;;;178    		NVIC_DisableIRQ(SPI1_IRQn);		
000018  200f              MOVS     r0,#0xf
00001a  f7fffffe          BL       NVIC_DisableIRQ
00001e  e005              B        |L4.44|
                  |L4.32|
;;;179    	else if((uint32_t)SpiPort == SPI2_BASE)
000020  4805              LDR      r0,|L4.56|
000022  4284              CMP      r4,r0
000024  d102              BNE      |L4.44|
;;;180    		NVIC_DisableIRQ(SPI2_IRQn);			
000026  2010              MOVS     r0,#0x10
000028  f7fffffe          BL       NVIC_DisableIRQ
                  |L4.44|
;;;181    }
00002c  bd10              POP      {r4,pc}
;;;182    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x40030000
                  |L4.52|
                          DCD      0x40130000
                  |L4.56|
                          DCD      0x400d0000

                          AREA ||i.SPI_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_DeInit PROC
;;;51       */
;;;52     void SPI_DeInit(SPI_TypeDef *SpiPort)
000000  490f              LDR      r1,|L5.64|
;;;53     {	
;;;54     	if((uint32_t)SpiPort == SPI0_BASE)
000002  4288              CMP      r0,r1
000004  d106              BNE      |L5.20|
;;;55     		CLK->APBCLK &= ~CLK_APBCLK_SPI0_EN;
000006  490f              LDR      r1,|L5.68|
000008  6889              LDR      r1,[r1,#8]
00000a  1482              ASRS     r2,r0,#18
00000c  4391              BICS     r1,r1,r2
00000e  4a0d              LDR      r2,|L5.68|
000010  6091              STR      r1,[r2,#8]
000012  e014              B        |L5.62|
                  |L5.20|
;;;56     	else if((uint32_t)SpiPort == SPI1_BASE)
000014  490c              LDR      r1,|L5.72|
000016  4288              CMP      r0,r1
000018  d107              BNE      |L5.42|
;;;57     		CLK->APBCLK &= ~CLK_APBCLK_SPI1_EN;
00001a  490a              LDR      r1,|L5.68|
00001c  6889              LDR      r1,[r1,#8]
00001e  2201              MOVS     r2,#1
000020  0352              LSLS     r2,r2,#13
000022  4391              BICS     r1,r1,r2
000024  4a07              LDR      r2,|L5.68|
000026  6091              STR      r1,[r2,#8]
000028  e009              B        |L5.62|
                  |L5.42|
;;;58     	else if((uint32_t)SpiPort == SPI2_BASE)
00002a  4908              LDR      r1,|L5.76|
00002c  4288              CMP      r0,r1
00002e  d106              BNE      |L5.62|
;;;59     		CLK->APBCLK &= ~CLK_APBCLK_SPI2_EN;	
000030  4904              LDR      r1,|L5.68|
000032  6889              LDR      r1,[r1,#8]
000034  2201              MOVS     r2,#1
000036  0392              LSLS     r2,r2,#14
000038  4391              BICS     r1,r1,r2
00003a  4a02              LDR      r2,|L5.68|
00003c  6091              STR      r1,[r2,#8]
                  |L5.62|
;;;60     }
00003e  4770              BX       lr
;;;61     
                          ENDP

                  |L5.64|
                          DCD      0x40030000
                  |L5.68|
                          DCD      0x50000200
                  |L5.72|
                          DCD      0x40130000
                  |L5.76|
                          DCD      0x400d0000

                          AREA ||i.SPI_Disable3WireStartInt||, CODE, READONLY, ALIGN=2

                  SPI_Disable3WireStartInt PROC
;;;468      */
;;;469    void SPI_Disable3WireStartInt(SPI_TypeDef *SpiPort)
000000  b510              PUSH     {r4,lr}
;;;470    {    
000002  4604              MOV      r4,r0
;;;471        SpiPort->SSR &= ~SPI_SSR_SSTA_INTEN;
000004  68e0              LDR      r0,[r4,#0xc]
000006  2101              MOVS     r1,#1
000008  0249              LSLS     r1,r1,#9
00000a  4388              BICS     r0,r0,r1
00000c  60e0              STR      r0,[r4,#0xc]
;;;472        
;;;473        if((uint32_t)SpiPort == SPI0_BASE)	
00000e  480a              LDR      r0,|L6.56|
000010  4284              CMP      r4,r0
000012  d103              BNE      |L6.28|
;;;474    		NVIC_DisableIRQ(SPI0_IRQn);
000014  200e              MOVS     r0,#0xe
000016  f7fffffe          BL       NVIC_DisableIRQ
00001a  e00c              B        |L6.54|
                  |L6.28|
;;;475    	else if((uint32_t)SpiPort == SPI1_BASE)	
00001c  4807              LDR      r0,|L6.60|
00001e  4284              CMP      r4,r0
000020  d103              BNE      |L6.42|
;;;476    		NVIC_DisableIRQ(SPI1_IRQn);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       NVIC_DisableIRQ
000028  e005              B        |L6.54|
                  |L6.42|
;;;477    	else if((uint32_t)SpiPort == SPI2_BASE)		
00002a  4805              LDR      r0,|L6.64|
00002c  4284              CMP      r4,r0
00002e  d102              BNE      |L6.54|
;;;478    		NVIC_DisableIRQ(SPI2_IRQn);   
000030  2010              MOVS     r0,#0x10
000032  f7fffffe          BL       NVIC_DisableIRQ
                  |L6.54|
;;;479    }
000036  bd10              POP      {r4,pc}
;;;480    
                          ENDP

                  |L6.56|
                          DCD      0x40030000
                  |L6.60|
                          DCD      0x40130000
                  |L6.64|
                          DCD      0x400d0000

                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=2

                  SPI_DisableInt PROC
;;;325      */
;;;326    void SPI_DisableInt(SPI_TypeDef *SpiPort)
000000  b510              PUSH     {r4,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328    	SpiPort->CTL &= ~SPI_CTL_INTEN;
000004  6820              LDR      r0,[r4,#0]
000006  2101              MOVS     r1,#1
000008  0449              LSLS     r1,r1,#17
00000a  4388              BICS     r0,r0,r1
00000c  6020              STR      r0,[r4,#0]
;;;329    
;;;330    	if((uint32_t)SpiPort == SPI0_BASE)	
00000e  480a              LDR      r0,|L7.56|
000010  4284              CMP      r4,r0
000012  d103              BNE      |L7.28|
;;;331    		NVIC_DisableIRQ(SPI0_IRQn);
000014  200e              MOVS     r0,#0xe
000016  f7fffffe          BL       NVIC_DisableIRQ
00001a  e00c              B        |L7.54|
                  |L7.28|
;;;332    	else if((uint32_t)SpiPort == SPI1_BASE)	
00001c  4807              LDR      r0,|L7.60|
00001e  4284              CMP      r4,r0
000020  d103              BNE      |L7.42|
;;;333    		NVIC_DisableIRQ(SPI1_IRQn);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       NVIC_DisableIRQ
000028  e005              B        |L7.54|
                  |L7.42|
;;;334    	else if((uint32_t)SpiPort == SPI2_BASE)		
00002a  4805              LDR      r0,|L7.64|
00002c  4284              CMP      r4,r0
00002e  d102              BNE      |L7.54|
;;;335    		NVIC_DisableIRQ(SPI2_IRQn);
000030  2010              MOVS     r0,#0x10
000032  f7fffffe          BL       NVIC_DisableIRQ
                  |L7.54|
;;;336    }
000036  bd10              POP      {r4,pc}
;;;337    
                          ENDP

                  |L7.56|
                          DCD      0x40030000
                  |L7.60|
                          DCD      0x40130000
                  |L7.64|
                          DCD      0x400d0000

                          AREA ||i.SPI_DumpRxRegister||, CODE, READONLY, ALIGN=1

                  SPI_DumpRxRegister PROC
;;;378      */
;;;379    uint32_t SPI_DumpRxRegister(SPI_TypeDef *SpiPort, uint32_t *pu32Buf, uint32_t u32DataCount)
000000  4603              MOV      r3,r0
;;;380    {
;;;381    	assert_param(SPI_CHECK_SET_DATAREG_NUM);
;;;382    	
;;;383    	pu32Buf[0] = SpiPort->RX0;
000002  6918              LDR      r0,[r3,#0x10]
000004  6008              STR      r0,[r1,#0]
;;;384    	
;;;385    	if(u32DataCount == 2)
000006  2a02              CMP      r2,#2
000008  d101              BNE      |L8.14|
;;;386    		pu32Buf[1] = SpiPort->RX1;
00000a  6958              LDR      r0,[r3,#0x14]
00000c  6048              STR      r0,[r1,#4]
                  |L8.14|
;;;387    	
;;;388        return u32DataCount;
00000e  4610              MOV      r0,r2
;;;389    }
000010  4770              BX       lr
;;;390    
                          ENDP


                          AREA ||i.SPI_Enable3WireStartInt||, CODE, READONLY, ALIGN=2

                  SPI_Enable3WireStartInt PROC
;;;442      */
;;;443    void SPI_Enable3WireStartInt(SPI_TypeDef *SpiPort)
000000  b510              PUSH     {r4,lr}
;;;444    { 
000002  4604              MOV      r4,r0
;;;445        SpiPort->SSR |= SPI_SSR_SSTA_INTEN;
000004  68e0              LDR      r0,[r4,#0xc]
000006  2101              MOVS     r1,#1
000008  0249              LSLS     r1,r1,#9
00000a  4308              ORRS     r0,r0,r1
00000c  60e0              STR      r0,[r4,#0xc]
;;;446    
;;;447        if((uint32_t)SpiPort == SPI0_BASE)	
00000e  4810              LDR      r0,|L9.80|
000010  4284              CMP      r4,r0
000012  d107              BNE      |L9.36|
;;;448    	{
;;;449    		NVIC_EnableIRQ(SPI0_IRQn);
000014  200e              MOVS     r0,#0xe
000016  f7fffffe          BL       NVIC_EnableIRQ
;;;450    		NVIC_SetPriority(SPI0_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
00001a  2102              MOVS     r1,#2
00001c  200e              MOVS     r0,#0xe
00001e  f7fffffe          BL       NVIC_SetPriority
000022  e014              B        |L9.78|
                  |L9.36|
;;;451    	}
;;;452    	else if((uint32_t)SpiPort == SPI1_BASE)	
000024  480b              LDR      r0,|L9.84|
000026  4284              CMP      r4,r0
000028  d107              BNE      |L9.58|
;;;453    	{	
;;;454    		NVIC_EnableIRQ(SPI1_IRQn);
00002a  200f              MOVS     r0,#0xf
00002c  f7fffffe          BL       NVIC_EnableIRQ
;;;455    		NVIC_SetPriority(SPI1_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
000030  2102              MOVS     r1,#2
000032  200f              MOVS     r0,#0xf
000034  f7fffffe          BL       NVIC_SetPriority
000038  e009              B        |L9.78|
                  |L9.58|
;;;456    	}
;;;457    	else if((uint32_t)SpiPort == SPI2_BASE)
00003a  4807              LDR      r0,|L9.88|
00003c  4284              CMP      r4,r0
00003e  d106              BNE      |L9.78|
;;;458    	{	
;;;459    		NVIC_EnableIRQ(SPI2_IRQn);
000040  2010              MOVS     r0,#0x10
000042  f7fffffe          BL       NVIC_EnableIRQ
;;;460    		NVIC_SetPriority(SPI2_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
000046  2102              MOVS     r1,#2
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       NVIC_SetPriority
                  |L9.78|
;;;461    	}
;;;462    }   
00004e  bd10              POP      {r4,pc}
;;;463    
                          ENDP

                  |L9.80|
                          DCD      0x40030000
                  |L9.84|
                          DCD      0x40130000
                  |L9.88|
                          DCD      0x400d0000

                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=2

                  SPI_EnableInt PROC
;;;308      */
;;;309    void SPI_EnableInt(SPI_TypeDef *SpiPort)
000000  b510              PUSH     {r4,lr}
;;;310    {	
000002  4604              MOV      r4,r0
;;;311    	SpiPort->CTL |= SPI_CTL_INTEN;
000004  6820              LDR      r0,[r4,#0]
000006  2101              MOVS     r1,#1
000008  0449              LSLS     r1,r1,#17
00000a  4308              ORRS     r0,r0,r1
00000c  6020              STR      r0,[r4,#0]
;;;312    	
;;;313    	if((uint32_t)SpiPort == SPI0_BASE)	
00000e  480a              LDR      r0,|L10.56|
000010  4284              CMP      r4,r0
000012  d103              BNE      |L10.28|
;;;314    		NVIC_EnableIRQ(SPI0_IRQn);
000014  200e              MOVS     r0,#0xe
000016  f7fffffe          BL       NVIC_EnableIRQ
00001a  e00c              B        |L10.54|
                  |L10.28|
;;;315    	else if((uint32_t)SpiPort == SPI1_BASE)	
00001c  4807              LDR      r0,|L10.60|
00001e  4284              CMP      r4,r0
000020  d103              BNE      |L10.42|
;;;316    		NVIC_EnableIRQ(SPI1_IRQn);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       NVIC_EnableIRQ
000028  e005              B        |L10.54|
                  |L10.42|
;;;317    	else if((uint32_t)SpiPort == SPI2_BASE)		
00002a  4805              LDR      r0,|L10.64|
00002c  4284              CMP      r4,r0
00002e  d102              BNE      |L10.54|
;;;318    		NVIC_EnableIRQ(SPI2_IRQn);
000030  2010              MOVS     r0,#0x10
000032  f7fffffe          BL       NVIC_EnableIRQ
                  |L10.54|
;;;319    }	
000036  bd10              POP      {r4,pc}
;;;320    
                          ENDP

                  |L10.56|
                          DCD      0x40030000
                  |L10.60|
                          DCD      0x40130000
                  |L10.64|
                          DCD      0x400d0000

                          AREA ||i.SPI_FIFORead16||, CODE, READONLY, ALIGN=1

                  SPI_FIFORead16 PROC
;;;631      */
;;;632    int32_t SPI_FIFORead16(SPI_TypeDef *SpiPort, uint16_t *pu16RxBuf, uint32_t u32ReadLength)
000000  b570              PUSH     {r4-r6,lr}
;;;633    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;634    	uint32_t  u32Count, u32delayno;
;;;635    		 	
;;;636    	for (u32Count=0; u32Count<u32ReadLength; u32Count++)
000006  2100              MOVS     r1,#0
000008  e011              B        |L11.46|
                  |L11.10|
;;;637        {
;;;638        	u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;639    	   	while (SpiPort->STATUS & SPI_STATUS_RX_EMPTY)  /* Wait Rx is not empty and Time-out manner */
00000c  e007              B        |L11.30|
                  |L11.14|
;;;640            {
;;;641           	    u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;642           	    if ( u32delayno >= 0x40000000 )     	    
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d302              BCC      |L11.30|
;;;643           	       return SPI_ERR_TIMEOUT;   
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
                  |L11.28|
;;;644    				   
;;;645            }
;;;646            pu16RxBuf[u32Count] = SpiPort->RX0;
;;;647        }
;;;648        
;;;649        return E_SUCCESS;
;;;650    }
00001c  bd70              POP      {r4-r6,pc}
                  |L11.30|
00001e  6858              LDR      r0,[r3,#4]            ;639
000020  07c0              LSLS     r0,r0,#31             ;639
000022  0fc0              LSRS     r0,r0,#31             ;639
000024  d1f3              BNE      |L11.14|
000026  6918              LDR      r0,[r3,#0x10]         ;646
000028  004e              LSLS     r6,r1,#1              ;646
00002a  53a0              STRH     r0,[r4,r6]            ;646
00002c  1c49              ADDS     r1,r1,#1              ;636
                  |L11.46|
00002e  4291              CMP      r1,r2                 ;636
000030  d3eb              BCC      |L11.10|
000032  2000              MOVS     r0,#0                 ;649
000034  e7f2              B        |L11.28|
;;;651    
                          ENDP


                          AREA ||i.SPI_FIFORead32||, CODE, READONLY, ALIGN=1

                  SPI_FIFORead32 PROC
;;;659      */
;;;660    int32_t SPI_FIFORead32(SPI_TypeDef *SpiPort, uint32_t *pu32RxBuf, uint32_t u32ReadLength)
000000  b570              PUSH     {r4-r6,lr}
;;;661    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;662    	uint32_t  u32Count, u32delayno;
;;;663    		 	
;;;664    	for (u32Count=0; u32Count<u32ReadLength; u32Count++)
000006  2100              MOVS     r1,#0
000008  e011              B        |L12.46|
                  |L12.10|
;;;665        {
;;;666        	u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;667    	   	while (SpiPort->STATUS & SPI_STATUS_RX_EMPTY)  /* Wait Rx is not empty and Time-out manner */
00000c  e007              B        |L12.30|
                  |L12.14|
;;;668            {
;;;669           	    u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;670           	    if ( u32delayno >= 0x40000000 )     	    
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d302              BCC      |L12.30|
;;;671           	       return SPI_ERR_TIMEOUT;   
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
                  |L12.28|
;;;672    				   
;;;673            }
;;;674            pu32RxBuf[u32Count] = SpiPort->RX0;
;;;675        }
;;;676        
;;;677        return E_SUCCESS;
;;;678    }
00001c  bd70              POP      {r4-r6,pc}
                  |L12.30|
00001e  6858              LDR      r0,[r3,#4]            ;667
000020  07c0              LSLS     r0,r0,#31             ;667
000022  0fc0              LSRS     r0,r0,#31             ;667
000024  d1f3              BNE      |L12.14|
000026  6918              LDR      r0,[r3,#0x10]         ;674
000028  008e              LSLS     r6,r1,#2              ;674
00002a  51a0              STR      r0,[r4,r6]            ;674
00002c  1c49              ADDS     r1,r1,#1              ;664
                  |L12.46|
00002e  4291              CMP      r1,r2                 ;664
000030  d3eb              BCC      |L12.10|
000032  2000              MOVS     r0,#0                 ;677
000034  e7f2              B        |L12.28|
;;;679    
                          ENDP


                          AREA ||i.SPI_FIFORead8||, CODE, READONLY, ALIGN=1

                  SPI_FIFORead8 PROC
;;;603      */
;;;604    int32_t SPI_FIFORead8(SPI_TypeDef *SpiPort, uint8_t *pu8RxBuf, uint32_t u32ReadLength)
000000  b530              PUSH     {r4,r5,lr}
;;;605    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;606    	uint32_t  u32Count, u32delayno;
;;;607    		 	
;;;608    	for (u32Count=0; u32Count<u32ReadLength; u32Count++)
000006  2100              MOVS     r1,#0
000008  e010              B        |L13.44|
                  |L13.10|
;;;609        {
;;;610        	u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;611    	   	while (SpiPort->STATUS & SPI_STATUS_RX_EMPTY)  /* Wait Rx is not empty and Time-out manner */
00000c  e007              B        |L13.30|
                  |L13.14|
;;;612            {
;;;613           	    u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;614           	    if ( u32delayno >= 0x40000000 )     	    
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d302              BCC      |L13.30|
;;;615           	       return SPI_ERR_TIMEOUT;   
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
                  |L13.28|
;;;616    				   
;;;617            }
;;;618            pu8RxBuf[u32Count] = SpiPort->RX0;
;;;619        }
;;;620        
;;;621        return E_SUCCESS;
;;;622    }
00001c  bd30              POP      {r4,r5,pc}
                  |L13.30|
00001e  6858              LDR      r0,[r3,#4]            ;611
000020  07c0              LSLS     r0,r0,#31             ;611
000022  0fc0              LSRS     r0,r0,#31             ;611
000024  d1f3              BNE      |L13.14|
000026  6918              LDR      r0,[r3,#0x10]         ;618
000028  5460              STRB     r0,[r4,r1]            ;618
00002a  1c49              ADDS     r1,r1,#1              ;608
                  |L13.44|
00002c  4291              CMP      r1,r2                 ;608
00002e  d3ec              BCC      |L13.10|
000030  2000              MOVS     r0,#0                 ;621
000032  e7f3              B        |L13.28|
;;;623    
                          ENDP


                          AREA ||i.SPI_FIFOReadWrite16||, CODE, READONLY, ALIGN=1

                  SPI_FIFOReadWrite16 PROC
;;;735      */  
;;;736    void SPI_FIFOReadWrite16(SPI_TypeDef *SpiPort, uint16_t *pu16TxBuf, uint32_t *pu16RxBuf, uint32_t u32Length)
000000  b5ff              PUSH     {r0-r7,lr}
;;;737    {
000002  460c              MOV      r4,r1
;;;738    	uint32_t  u32Count, u32RxCount = 0;
000004  2100              MOVS     r1,#0
;;;739    	 
;;;740    	for (u32Count=0; u32Count<u32Length; u32Count++)
000006  2300              MOVS     r3,#0
000008  e025              B        |L14.86|
                  |L14.10|
;;;741        {    	
;;;742    	   	while (SpiPort->STATUS & SPI_STATUS_TX_FULL)  /* if Tx is full, process Rx */
00000a  e009              B        |L14.32|
                  |L14.12|
;;;743            {
;;;744           	    while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00000c  e004              B        |L14.24|
                  |L14.14|
;;;745       	    		pu16RxBuf[u32RxCount++] = SpiPort->RX0;				   
00000e  6906              LDR      r6,[r0,#0x10]
000010  460d              MOV      r5,r1
000012  1c49              ADDS     r1,r1,#1
000014  00ad              LSLS     r5,r5,#2
000016  5156              STR      r6,[r2,r5]
                  |L14.24|
000018  6845              LDR      r5,[r0,#4]            ;744
00001a  07ed              LSLS     r5,r5,#31             ;744
00001c  0fed              LSRS     r5,r5,#31             ;744
00001e  d0f6              BEQ      |L14.14|
                  |L14.32|
000020  6845              LDR      r5,[r0,#4]            ;742
000022  2608              MOVS     r6,#8                 ;742
000024  4235              TST      r5,r6                 ;742
000026  d1f1              BNE      |L14.12|
;;;746            }
;;;747            
;;;748            if(pu16TxBuf == NULL)
000028  2c00              CMP      r4,#0
00002a  d102              BNE      |L14.50|
;;;749            	SpiPort->TX0 = 0xFFFFFFFF;
00002c  1e65              SUBS     r5,r4,#1
00002e  6205              STR      r5,[r0,#0x20]
000030  e002              B        |L14.56|
                  |L14.50|
;;;750            else
;;;751            	SpiPort->TX0 = pu16TxBuf[u32Count];
000032  005d              LSLS     r5,r3,#1
000034  5b65              LDRH     r5,[r4,r5]
000036  6205              STR      r5,[r0,#0x20]
                  |L14.56|
;;;752    
;;;753            if(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))	/* check if rx has something */
000038  6845              LDR      r5,[r0,#4]
00003a  07ed              LSLS     r5,r5,#31
00003c  0fed              LSRS     r5,r5,#31
00003e  d109              BNE      |L14.84|
;;;754        	{
;;;755        		while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
000040  e004              B        |L14.76|
                  |L14.66|
;;;756        			pu16RxBuf[u32RxCount++] = SpiPort->RX0;
000042  6906              LDR      r6,[r0,#0x10]
000044  460d              MOV      r5,r1
000046  1c49              ADDS     r1,r1,#1
000048  00ad              LSLS     r5,r5,#2
00004a  5156              STR      r6,[r2,r5]
                  |L14.76|
00004c  6845              LDR      r5,[r0,#4]            ;755
00004e  07ed              LSLS     r5,r5,#31             ;755
000050  0fed              LSRS     r5,r5,#31             ;755
000052  d0f6              BEQ      |L14.66|
                  |L14.84|
000054  1c5b              ADDS     r3,r3,#1              ;740
                  |L14.86|
000056  9d03              LDR      r5,[sp,#0xc]          ;740
000058  42ab              CMP      r3,r5                 ;740
00005a  d3d6              BCC      |L14.10|
;;;757        	}
;;;758        }
;;;759        
;;;760        // SPI is still in progress, check Rx if something is in FIFO 
;;;761        while(SpiPort->CTL & SPI_CTL_GO_BUSY)
00005c  e009              B        |L14.114|
                  |L14.94|
;;;762        {
;;;763        	while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00005e  e004              B        |L14.106|
                  |L14.96|
;;;764        		pu16RxBuf[u32RxCount++] = SpiPort->RX0;
000060  6906              LDR      r6,[r0,#0x10]
000062  460d              MOV      r5,r1
000064  1c49              ADDS     r1,r1,#1
000066  00ad              LSLS     r5,r5,#2
000068  5156              STR      r6,[r2,r5]
                  |L14.106|
00006a  6845              LDR      r5,[r0,#4]            ;763
00006c  07ed              LSLS     r5,r5,#31             ;763
00006e  0fed              LSRS     r5,r5,#31             ;763
000070  d0f6              BEQ      |L14.96|
                  |L14.114|
000072  6805              LDR      r5,[r0,#0]            ;761
000074  07ed              LSLS     r5,r5,#31             ;761
000076  0fed              LSRS     r5,r5,#31             ;761
000078  d1f1              BNE      |L14.94|
;;;765        }
;;;766        
;;;767        // SPI is finisned, but still need to check FIFO status
;;;768        while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00007a  e004              B        |L14.134|
                  |L14.124|
;;;769        	pu16RxBuf[u32RxCount++] = SpiPort->RX0;
00007c  6906              LDR      r6,[r0,#0x10]
00007e  460d              MOV      r5,r1
000080  1c49              ADDS     r1,r1,#1
000082  00ad              LSLS     r5,r5,#2
000084  5156              STR      r6,[r2,r5]
                  |L14.134|
000086  6845              LDR      r5,[r0,#4]            ;768
000088  07ed              LSLS     r5,r5,#31             ;768
00008a  0fed              LSRS     r5,r5,#31             ;768
00008c  d0f6              BEQ      |L14.124|
;;;770    }
00008e  bdff              POP      {r0-r7,pc}
;;;771    
                          ENDP


                          AREA ||i.SPI_FIFOReadWrite32||, CODE, READONLY, ALIGN=1

                  SPI_FIFOReadWrite32 PROC
;;;781      */  
;;;782    void SPI_FIFOReadWrite32(SPI_TypeDef *SpiPort, uint32_t *pu32TxBuf, uint32_t *pu32RxBuf, uint32_t u32Length)
000000  b5ff              PUSH     {r0-r7,lr}
;;;783    {
000002  460c              MOV      r4,r1
;;;784    	uint32_t  u32Count, u32RxCount = 0;
000004  2100              MOVS     r1,#0
;;;785    	 
;;;786    	for (u32Count=0; u32Count<u32Length; u32Count++)
000006  2300              MOVS     r3,#0
000008  e025              B        |L15.86|
                  |L15.10|
;;;787        {    	
;;;788    	   	while (SpiPort->STATUS & SPI_STATUS_TX_FULL)  /* if Tx is full, process Rx */
00000a  e009              B        |L15.32|
                  |L15.12|
;;;789            {
;;;790           	    while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00000c  e004              B        |L15.24|
                  |L15.14|
;;;791       	    		pu32RxBuf[u32RxCount++] = SpiPort->RX0;				   
00000e  6906              LDR      r6,[r0,#0x10]
000010  460d              MOV      r5,r1
000012  1c49              ADDS     r1,r1,#1
000014  00ad              LSLS     r5,r5,#2
000016  5156              STR      r6,[r2,r5]
                  |L15.24|
000018  6845              LDR      r5,[r0,#4]            ;790
00001a  07ed              LSLS     r5,r5,#31             ;790
00001c  0fed              LSRS     r5,r5,#31             ;790
00001e  d0f6              BEQ      |L15.14|
                  |L15.32|
000020  6845              LDR      r5,[r0,#4]            ;788
000022  2608              MOVS     r6,#8                 ;788
000024  4235              TST      r5,r6                 ;788
000026  d1f1              BNE      |L15.12|
;;;792            }
;;;793            
;;;794            if(pu32TxBuf == NULL)
000028  2c00              CMP      r4,#0
00002a  d102              BNE      |L15.50|
;;;795            	SpiPort->TX0 = 0xFFFFFFFF;
00002c  1e65              SUBS     r5,r4,#1
00002e  6205              STR      r5,[r0,#0x20]
000030  e002              B        |L15.56|
                  |L15.50|
;;;796            else
;;;797            	SpiPort->TX0 = pu32TxBuf[u32Count];
000032  009d              LSLS     r5,r3,#2
000034  5965              LDR      r5,[r4,r5]
000036  6205              STR      r5,[r0,#0x20]
                  |L15.56|
;;;798    
;;;799            if(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))	/* check if rx has something */
000038  6845              LDR      r5,[r0,#4]
00003a  07ed              LSLS     r5,r5,#31
00003c  0fed              LSRS     r5,r5,#31
00003e  d109              BNE      |L15.84|
;;;800        	{
;;;801        		while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
000040  e004              B        |L15.76|
                  |L15.66|
;;;802        			pu32RxBuf[u32RxCount++] = SpiPort->RX0;
000042  6906              LDR      r6,[r0,#0x10]
000044  460d              MOV      r5,r1
000046  1c49              ADDS     r1,r1,#1
000048  00ad              LSLS     r5,r5,#2
00004a  5156              STR      r6,[r2,r5]
                  |L15.76|
00004c  6845              LDR      r5,[r0,#4]            ;801
00004e  07ed              LSLS     r5,r5,#31             ;801
000050  0fed              LSRS     r5,r5,#31             ;801
000052  d0f6              BEQ      |L15.66|
                  |L15.84|
000054  1c5b              ADDS     r3,r3,#1              ;786
                  |L15.86|
000056  9d03              LDR      r5,[sp,#0xc]          ;786
000058  42ab              CMP      r3,r5                 ;786
00005a  d3d6              BCC      |L15.10|
;;;803        	}
;;;804        }
;;;805        
;;;806        // SPI is still in progress, check Rx if something is in FIFO 
;;;807        while(SpiPort->CTL & SPI_CTL_GO_BUSY)
00005c  e009              B        |L15.114|
                  |L15.94|
;;;808        {
;;;809        	while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00005e  e004              B        |L15.106|
                  |L15.96|
;;;810        		pu32RxBuf[u32RxCount++] = SpiPort->RX0;
000060  6906              LDR      r6,[r0,#0x10]
000062  460d              MOV      r5,r1
000064  1c49              ADDS     r1,r1,#1
000066  00ad              LSLS     r5,r5,#2
000068  5156              STR      r6,[r2,r5]
                  |L15.106|
00006a  6845              LDR      r5,[r0,#4]            ;809
00006c  07ed              LSLS     r5,r5,#31             ;809
00006e  0fed              LSRS     r5,r5,#31             ;809
000070  d0f6              BEQ      |L15.96|
                  |L15.114|
000072  6805              LDR      r5,[r0,#0]            ;807
000074  07ed              LSLS     r5,r5,#31             ;807
000076  0fed              LSRS     r5,r5,#31             ;807
000078  d1f1              BNE      |L15.94|
;;;811        }
;;;812        
;;;813        // SPI is finisned, but still need to check FIFO status
;;;814        while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00007a  e004              B        |L15.134|
                  |L15.124|
;;;815        	pu32RxBuf[u32RxCount++] = SpiPort->RX0;
00007c  6906              LDR      r6,[r0,#0x10]
00007e  460d              MOV      r5,r1
000080  1c49              ADDS     r1,r1,#1
000082  00ad              LSLS     r5,r5,#2
000084  5156              STR      r6,[r2,r5]
                  |L15.134|
000086  6845              LDR      r5,[r0,#4]            ;814
000088  07ed              LSLS     r5,r5,#31             ;814
00008a  0fed              LSRS     r5,r5,#31             ;814
00008c  d0f6              BEQ      |L15.124|
;;;816    }
00008e  bdff              POP      {r0-r7,pc}
;;;817    
                          ENDP


                          AREA ||i.SPI_FIFOReadWrite8||, CODE, READONLY, ALIGN=1

                  SPI_FIFOReadWrite8 PROC
;;;689      */  
;;;690    void SPI_FIFOReadWrite8(SPI_TypeDef *SpiPort, uint8_t *pu8TxBuf, uint8_t *pu8RxBuf, uint32_t u32Length)
000000  b5ff              PUSH     {r0-r7,lr}
;;;691    {
000002  460c              MOV      r4,r1
;;;692    	uint32_t  u32Count, u32RxCount = 0;
000004  2100              MOVS     r1,#0
;;;693    	 
;;;694    	for (u32Count=0; u32Count<u32Length; u32Count++)
000006  2300              MOVS     r3,#0
000008  e024              B        |L16.84|
                  |L16.10|
;;;695        {    	
;;;696    	   	while (SpiPort->STATUS & SPI_STATUS_TX_FULL)  /* if Tx is full, process Rx */
00000a  e009              B        |L16.32|
                  |L16.12|
;;;697            {
;;;698           	    while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00000c  e004              B        |L16.24|
                  |L16.14|
;;;699       	    		pu8RxBuf[u32RxCount++] = SpiPort->RX0;				   
00000e  6905              LDR      r5,[r0,#0x10]
000010  b2ee              UXTB     r6,r5
000012  460d              MOV      r5,r1
000014  1c49              ADDS     r1,r1,#1
000016  5556              STRB     r6,[r2,r5]
                  |L16.24|
000018  6845              LDR      r5,[r0,#4]            ;698
00001a  07ed              LSLS     r5,r5,#31             ;698
00001c  0fed              LSRS     r5,r5,#31             ;698
00001e  d0f6              BEQ      |L16.14|
                  |L16.32|
000020  6845              LDR      r5,[r0,#4]            ;696
000022  2608              MOVS     r6,#8                 ;696
000024  4235              TST      r5,r6                 ;696
000026  d1f1              BNE      |L16.12|
;;;700            }
;;;701            
;;;702            if(pu8TxBuf == NULL)
000028  2c00              CMP      r4,#0
00002a  d102              BNE      |L16.50|
;;;703            	SpiPort->TX0 = 0xFFFFFFFF;
00002c  1e65              SUBS     r5,r4,#1
00002e  6205              STR      r5,[r0,#0x20]
000030  e001              B        |L16.54|
                  |L16.50|
;;;704            else
;;;705            	SpiPort->TX0 = pu8TxBuf[u32Count];
000032  5ce5              LDRB     r5,[r4,r3]
000034  6205              STR      r5,[r0,#0x20]
                  |L16.54|
;;;706    
;;;707            if(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))	/* check if rx has something */
000036  6845              LDR      r5,[r0,#4]
000038  07ed              LSLS     r5,r5,#31
00003a  0fed              LSRS     r5,r5,#31
00003c  d109              BNE      |L16.82|
;;;708        	{
;;;709        		while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00003e  e004              B        |L16.74|
                  |L16.64|
;;;710        			pu8RxBuf[u32RxCount++] = SpiPort->RX0;
000040  6905              LDR      r5,[r0,#0x10]
000042  b2ee              UXTB     r6,r5
000044  460d              MOV      r5,r1
000046  1c49              ADDS     r1,r1,#1
000048  5556              STRB     r6,[r2,r5]
                  |L16.74|
00004a  6845              LDR      r5,[r0,#4]            ;709
00004c  07ed              LSLS     r5,r5,#31             ;709
00004e  0fed              LSRS     r5,r5,#31             ;709
000050  d0f6              BEQ      |L16.64|
                  |L16.82|
000052  1c5b              ADDS     r3,r3,#1              ;694
                  |L16.84|
000054  9d03              LDR      r5,[sp,#0xc]          ;694
000056  42ab              CMP      r3,r5                 ;694
000058  d3d7              BCC      |L16.10|
;;;711        	}
;;;712        }
;;;713        
;;;714        // SPI is still in progress, check Rx if something is in FIFO 
;;;715        while(SpiPort->CTL & SPI_CTL_GO_BUSY)
00005a  e009              B        |L16.112|
                  |L16.92|
;;;716        {
;;;717        	while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
00005c  e004              B        |L16.104|
                  |L16.94|
;;;718        		pu8RxBuf[u32RxCount++] = SpiPort->RX0;
00005e  6905              LDR      r5,[r0,#0x10]
000060  b2ee              UXTB     r6,r5
000062  460d              MOV      r5,r1
000064  1c49              ADDS     r1,r1,#1
000066  5556              STRB     r6,[r2,r5]
                  |L16.104|
000068  6845              LDR      r5,[r0,#4]            ;717
00006a  07ed              LSLS     r5,r5,#31             ;717
00006c  0fed              LSRS     r5,r5,#31             ;717
00006e  d0f6              BEQ      |L16.94|
                  |L16.112|
000070  6805              LDR      r5,[r0,#0]            ;715
000072  07ed              LSLS     r5,r5,#31             ;715
000074  0fed              LSRS     r5,r5,#31             ;715
000076  d1f1              BNE      |L16.92|
;;;719        }
;;;720        
;;;721        // SPI is finisned, but still need to check FIFO status
;;;722        while(!(SpiPort->STATUS & SPI_STATUS_RX_EMPTY))
000078  e004              B        |L16.132|
                  |L16.122|
;;;723        	pu8RxBuf[u32RxCount++] = SpiPort->RX0;
00007a  6905              LDR      r5,[r0,#0x10]
00007c  b2ee              UXTB     r6,r5
00007e  460d              MOV      r5,r1
000080  1c49              ADDS     r1,r1,#1
000082  5556              STRB     r6,[r2,r5]
                  |L16.132|
000084  6845              LDR      r5,[r0,#4]            ;722
000086  07ed              LSLS     r5,r5,#31             ;722
000088  0fed              LSRS     r5,r5,#31             ;722
00008a  d0f6              BEQ      |L16.122|
;;;724    }
00008c  bdff              POP      {r0-r7,pc}
;;;725    
                          ENDP


                          AREA ||i.SPI_FIFOWrite16||, CODE, READONLY, ALIGN=1

                  SPI_FIFOWrite16 PROC
;;;547      */
;;;548    int32_t SPI_FIFOWrite16(SPI_TypeDef *SpiPort, uint16_t *pu16TxBuf, uint32_t u32WriteLength)
000000  b570              PUSH     {r4-r6,lr}
;;;549    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;550    	uint32_t  u32Count, u32delayno;
;;;551    	 
;;;552    	for (u32Count=0; u32Count<u32WriteLength; u32Count++)
000006  2100              MOVS     r1,#0
000008  e011              B        |L17.46|
                  |L17.10|
;;;553        {
;;;554        	u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;555    	   	while (SpiPort->STATUS & SPI_STATUS_TX_FULL)  /* Wait Tx is empty and Time-out manner */
00000c  e007              B        |L17.30|
                  |L17.14|
;;;556            {
;;;557           	    u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;558           	    if ( u32delayno >= 0x40000000 )     	    
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d302              BCC      |L17.30|
;;;559           	       return SPI_ERR_TIMEOUT;   
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
                  |L17.28|
;;;560    				   
;;;561            }
;;;562            SpiPort->TX0 = pu16TxBuf[u32Count];
;;;563        }
;;;564        
;;;565        return E_SUCCESS;
;;;566    }
00001c  bd70              POP      {r4-r6,pc}
                  |L17.30|
00001e  6858              LDR      r0,[r3,#4]            ;555
000020  2608              MOVS     r6,#8                 ;555
000022  4230              TST      r0,r6                 ;555
000024  d1f3              BNE      |L17.14|
000026  0048              LSLS     r0,r1,#1              ;562
000028  5a20              LDRH     r0,[r4,r0]            ;562
00002a  6218              STR      r0,[r3,#0x20]         ;562
00002c  1c49              ADDS     r1,r1,#1              ;552
                  |L17.46|
00002e  4291              CMP      r1,r2                 ;552
000030  d3eb              BCC      |L17.10|
000032  2000              MOVS     r0,#0                 ;565
000034  e7f2              B        |L17.28|
;;;567    
                          ENDP


                          AREA ||i.SPI_FIFOWrite32||, CODE, READONLY, ALIGN=1

                  SPI_FIFOWrite32 PROC
;;;575      */
;;;576    int32_t SPI_FIFOWrite32(SPI_TypeDef *SpiPort, uint32_t *pu32TxBuf, uint32_t u32WriteLength)
000000  b570              PUSH     {r4-r6,lr}
;;;577    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;578    	uint32_t  u32Count, u32delayno;
;;;579    	 
;;;580    	for (u32Count=0; u32Count<u32WriteLength; u32Count++)
000006  2100              MOVS     r1,#0
000008  e011              B        |L18.46|
                  |L18.10|
;;;581        {
;;;582        	u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;583    	   	while (SpiPort->STATUS & SPI_STATUS_TX_FULL)  /* Wait Tx is empty and Time-out manner */
00000c  e007              B        |L18.30|
                  |L18.14|
;;;584            {
;;;585           	    u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;586           	    if ( u32delayno >= 0x40000000 )     	    
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d302              BCC      |L18.30|
;;;587           	       return SPI_ERR_TIMEOUT;   
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
                  |L18.28|
;;;588    				   
;;;589            }
;;;590            SpiPort->TX0 = pu32TxBuf[u32Count];
;;;591        }
;;;592        
;;;593        return E_SUCCESS;
;;;594    }
00001c  bd70              POP      {r4-r6,pc}
                  |L18.30|
00001e  6858              LDR      r0,[r3,#4]            ;583
000020  2608              MOVS     r6,#8                 ;583
000022  4230              TST      r0,r6                 ;583
000024  d1f3              BNE      |L18.14|
000026  0088              LSLS     r0,r1,#2              ;590
000028  5820              LDR      r0,[r4,r0]            ;590
00002a  6218              STR      r0,[r3,#0x20]         ;590
00002c  1c49              ADDS     r1,r1,#1              ;580
                  |L18.46|
00002e  4291              CMP      r1,r2                 ;580
000030  d3eb              BCC      |L18.10|
000032  2000              MOVS     r0,#0                 ;593
000034  e7f2              B        |L18.28|
;;;595    
                          ENDP


                          AREA ||i.SPI_FIFOWrite8||, CODE, READONLY, ALIGN=1

                  SPI_FIFOWrite8 PROC
;;;519      */
;;;520    int32_t SPI_FIFOWrite8(SPI_TypeDef *SpiPort, uint8_t *pu8TxBuf, uint32_t u32WriteLength)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;522    	uint32_t  u32Count, u32delayno;
;;;523    	 
;;;524    	for (u32Count=0; u32Count<u32WriteLength; u32Count++)
000006  2100              MOVS     r1,#0
000008  e010              B        |L19.44|
                  |L19.10|
;;;525        {
;;;526        	u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;527    	   	while (SpiPort->STATUS & SPI_STATUS_TX_FULL)  /* Wait Tx is empty and Time-out manner */
00000c  e007              B        |L19.30|
                  |L19.14|
;;;528            {
;;;529           	    u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;530           	    if ( u32delayno >= 0x40000000 )     	    
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d302              BCC      |L19.30|
;;;531           	       return SPI_ERR_TIMEOUT;   
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
                  |L19.28|
;;;532    				   
;;;533            }
;;;534            SpiPort->TX0 = pu8TxBuf[u32Count];
;;;535        }
;;;536        
;;;537        return E_SUCCESS;
;;;538    }
00001c  bd70              POP      {r4-r6,pc}
                  |L19.30|
00001e  6858              LDR      r0,[r3,#4]            ;527
000020  2608              MOVS     r6,#8                 ;527
000022  4230              TST      r0,r6                 ;527
000024  d1f3              BNE      |L19.14|
000026  5c60              LDRB     r0,[r4,r1]            ;534
000028  6218              STR      r0,[r3,#0x20]         ;534
00002a  1c49              ADDS     r1,r1,#1              ;524
                  |L19.44|
00002c  4291              CMP      r1,r2                 ;524
00002e  d3ec              BCC      |L19.10|
000030  2000              MOVS     r0,#0                 ;537
000032  e7f3              B        |L19.28|
;;;539    
                          ENDP


                          AREA ||i.SPI_GetClock1Freq||, CODE, READONLY, ALIGN=1

                  SPI_GetClock1Freq PROC
;;;276      */
;;;277    uint32_t SPI_GetClock1Freq(SPI_TypeDef *SpiPort)
000000  b570              PUSH     {r4-r6,lr}
;;;278    {
000002  4604              MOV      r4,r0
;;;279    	uint32_t u32Div;
;;;280    	uint32_t u32ApbClock;
;;;281    
;;;282    	u32ApbClock = SPI_GetSourceClockFreq(SpiPort);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI_GetSourceClockFreq
00000a  4606              MOV      r6,r0
;;;283    	u32Div = SpiPort->CLKDIV & SPI_CLKDIV_DIVIDER1_MASK;
00000c  68a0              LDR      r0,[r4,#8]
00000e  b2c5              UXTB     r5,r0
;;;284    	
;;;285    	if(u32Div == 0)	return u32ApbClock;
000010  2d00              CMP      r5,#0
000012  d101              BNE      |L20.24|
000014  4630              MOV      r0,r6
                  |L20.22|
;;;286    	else return ((u32ApbClock >> 1) / u32Div);   /* SPI_CLK = APB_CLK / (Divider * 2) */
;;;287    }
000016  bd70              POP      {r4-r6,pc}
                  |L20.24|
000018  0870              LSRS     r0,r6,#1              ;286
00001a  4629              MOV      r1,r5                 ;286
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  e7f9              B        |L20.22|
;;;288    
                          ENDP


                          AREA ||i.SPI_GetClock2Freq||, CODE, READONLY, ALIGN=1

                  SPI_GetClock2Freq PROC
;;;293      */
;;;294    uint32_t SPI_GetClock2Freq(SPI_TypeDef *SpiPort)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4604              MOV      r4,r0
;;;296    	uint32_t u32Div;
;;;297    	uint32_t u32ApbClock;
;;;298    
;;;299    	u32ApbClock = SPI_GetSourceClockFreq(SpiPort);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI_GetSourceClockFreq
00000a  4606              MOV      r6,r0
;;;300    	u32Div = (SpiPort->CLKDIV & SPI_CLKDIV_DIVIDER2_MASK) >> 16;
00000c  68a0              LDR      r0,[r4,#8]
00000e  21ff              MOVS     r1,#0xff
000010  0409              LSLS     r1,r1,#16
000012  4008              ANDS     r0,r0,r1
000014  0c05              LSRS     r5,r0,#16
;;;301    	return ((u32ApbClock >> 1) / (u32Div + 1));   /* SPI_CLK = APB_CLK / ((Divider + 1) * 2) */
000016  0870              LSRS     r0,r6,#1
000018  1c69              ADDS     r1,r5,#1
00001a  f7fffffe          BL       __aeabi_uidivmod
;;;302    }
00001e  bd70              POP      {r4-r6,pc}
;;;303    
                          ENDP


                          AREA ||i.SPI_GetSourceClockFreq||, CODE, READONLY, ALIGN=2

                  SPI_GetSourceClockFreq PROC
;;;822      */
;;;823    uint32_t SPI_GetSourceClockFreq(SPI_TypeDef *SpiPort)
000000  b570              PUSH     {r4-r6,lr}
;;;824    {	
000002  4605              MOV      r5,r0
;;;825    	//	Clock Source is form:
;;;826    	//  (PLL, HXT, HIRC, LXT, LIRC) --> [HCLK_Div] ---> HCLK --->
;;;827    	//    |                                                      [SPI_Div] ====> SPI clock
;;;828    	//    +--------------------------------------------PLL------>
;;;829    	//
;;;830    	uint32_t u32Freq = 12000000, u32ClkSrcSel;
000004  4e15              LDR      r6,|L22.92|
;;;831    	
;;;832    	if((uint32_t)SpiPort == SPI0_BASE)
000006  4816              LDR      r0,|L22.96|
000008  4285              CMP      r5,r0
00000a  d104              BNE      |L22.22|
;;;833    		u32ClkSrcSel = CLK->CLKSEL2 & CLK_CLKSEL2_SPI0_MASK;
00000c  4815              LDR      r0,|L22.100|
00000e  6984              LDR      r4,[r0,#0x18]
000010  02c1              LSLS     r1,r0,#11
000012  400c              ANDS     r4,r4,r1
000014  e00b              B        |L22.46|
                  |L22.22|
;;;834    	else if((uint32_t)SpiPort == SPI1_BASE)
000016  4814              LDR      r0,|L22.104|
000018  4285              CMP      r5,r0
00001a  d104              BNE      |L22.38|
;;;835    		u32ClkSrcSel = CLK->CLKSEL2 & CLK_CLKSEL2_SPI1_MASK;
00001c  4811              LDR      r0,|L22.100|
00001e  6984              LDR      r4,[r0,#0x18]
000020  0301              LSLS     r1,r0,#12
000022  400c              ANDS     r4,r4,r1
000024  e003              B        |L22.46|
                  |L22.38|
;;;836    	else 
;;;837    		u32ClkSrcSel = CLK->CLKSEL2 & CLK_CLKSEL2_SPI2_MASK;
000026  480f              LDR      r0,|L22.100|
000028  6984              LDR      r4,[r0,#0x18]
00002a  0341              LSLS     r1,r0,#13
00002c  400c              ANDS     r4,r4,r1
                  |L22.46|
;;;838    		
;;;839    		
;;;840    	if((u32ClkSrcSel == CLK_CLKSEL2_SPI0_PLL)  ||
00002e  2c00              CMP      r4,#0
000030  d001              BEQ      |L22.54|
;;;841    		(u32ClkSrcSel == CLK_CLKSEL2_SPI1_PLL) ||
000032  d000              BEQ      |L22.54|
;;;842    		(u32ClkSrcSel == CLK_CLKSEL2_SPI2_PLL))
000034  d102              BNE      |L22.60|
                  |L22.54|
;;;843    	{
;;;844    		return SYS_GetPLLClockFreq();
000036  f7fffffe          BL       SYS_GetPLLClockFreq
                  |L22.58|
;;;845    	}
;;;846    	
;;;847    	if((u32ClkSrcSel == CLK_CLKSEL2_SPI0_HCLK)  ||
;;;848    		(u32ClkSrcSel == CLK_CLKSEL2_SPI1_HCLK) ||
;;;849    		(u32ClkSrcSel == CLK_CLKSEL2_SPI2_HCLK))
;;;850    	{
;;;851    		return SYS_GetHCLKFreq();
;;;852    	}
;;;853    	
;;;854    	return u32Freq;
;;;855    }
00003a  bd70              POP      {r4-r6,pc}
                  |L22.60|
00003c  2001              MOVS     r0,#1                 ;847
00003e  0500              LSLS     r0,r0,#20             ;847
000040  4284              CMP      r4,r0                 ;847
000042  d005              BEQ      |L22.80|
000044  0040              LSLS     r0,r0,#1              ;848
000046  4284              CMP      r4,r0                 ;848
000048  d002              BEQ      |L22.80|
00004a  0040              LSLS     r0,r0,#1              ;849
00004c  4284              CMP      r4,r0                 ;849
00004e  d102              BNE      |L22.86|
                  |L22.80|
000050  f7fffffe          BL       SYS_GetHCLKFreq
000054  e7f1              B        |L22.58|
                  |L22.86|
000056  4630              MOV      r0,r6                 ;854
000058  e7ef              B        |L22.58|
;;;856    
                          ENDP

00005a  0000              DCW      0x0000
                  |L22.92|
                          DCD      0x00b71b00
                  |L22.96|
                          DCD      0x40030000
                  |L22.100|
                          DCD      0x50000200
                  |L22.104|
                          DCD      0x40130000

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;36       
;;;37     void SPI_Init(SPI_TypeDef *SpiPort)
000000  490f              LDR      r1,|L23.64|
;;;38     {	
;;;39     	if((uint32_t)SpiPort == SPI0_BASE)
000002  4288              CMP      r0,r1
000004  d106              BNE      |L23.20|
;;;40     		CLK->APBCLK |= CLK_APBCLK_SPI0_EN;		
000006  490f              LDR      r1,|L23.68|
000008  6889              LDR      r1,[r1,#8]
00000a  1482              ASRS     r2,r0,#18
00000c  4311              ORRS     r1,r1,r2
00000e  4a0d              LDR      r2,|L23.68|
000010  6091              STR      r1,[r2,#8]
000012  e014              B        |L23.62|
                  |L23.20|
;;;41     	else if((uint32_t)SpiPort == SPI1_BASE)
000014  490c              LDR      r1,|L23.72|
000016  4288              CMP      r0,r1
000018  d107              BNE      |L23.42|
;;;42     		CLK->APBCLK |= CLK_APBCLK_SPI1_EN;	
00001a  490a              LDR      r1,|L23.68|
00001c  6889              LDR      r1,[r1,#8]
00001e  2201              MOVS     r2,#1
000020  0352              LSLS     r2,r2,#13
000022  4311              ORRS     r1,r1,r2
000024  4a07              LDR      r2,|L23.68|
000026  6091              STR      r1,[r2,#8]
000028  e009              B        |L23.62|
                  |L23.42|
;;;43     	else if((uint32_t)SpiPort == SPI2_BASE)		
00002a  4908              LDR      r1,|L23.76|
00002c  4288              CMP      r0,r1
00002e  d106              BNE      |L23.62|
;;;44     		CLK->APBCLK |= CLK_APBCLK_SPI2_EN;	
000030  4904              LDR      r1,|L23.68|
000032  6889              LDR      r1,[r1,#8]
000034  2201              MOVS     r2,#1
000036  0392              LSLS     r2,r2,#14
000038  4311              ORRS     r1,r1,r2
00003a  4a02              LDR      r2,|L23.68|
00003c  6091              STR      r1,[r2,#8]
                  |L23.62|
;;;45     }
00003e  4770              BX       lr
;;;46     
                          ENDP

                  |L23.64|
                          DCD      0x40030000
                  |L23.68|
                          DCD      0x50000200
                  |L23.72|
                          DCD      0x40130000
                  |L23.76|
                          DCD      0x400d0000

                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;117    */
;;;118    int32_t SPI_Open(SPI_TypeDef *SpiPort, SPI_DATA_T *sParam)
000000  b510              PUSH     {r4,lr}
;;;119    {
000002  4602              MOV      r2,r0
;;;120    	int32_t i32TimeOut;
;;;121    	            
;;;122        /* Bit length 8 ~ 32 */
;;;123        assert_param(SPI_CHECK_BIT_LENGTH_0);
;;;124        	
;;;125    	if((uint32_t)SpiPort == SPI0_BASE)
000004  4835              LDR      r0,|L24.220|
000006  4282              CMP      r2,r0
000008  d10f              BNE      |L24.42|
;;;126    	{		
;;;127    		GCR->IPRST_CTL2 |= GCR_IPRSTCTL2_SPI0;
00000a  2005              MOVS     r0,#5
00000c  0700              LSLS     r0,r0,#28
00000e  68c0              LDR      r0,[r0,#0xc]
000010  1494              ASRS     r4,r2,#18
000012  4320              ORRS     r0,r0,r4
000014  2405              MOVS     r4,#5
000016  0724              LSLS     r4,r4,#28
000018  60e0              STR      r0,[r4,#0xc]
;;;128    		GCR->IPRST_CTL2 &= ~GCR_IPRSTCTL2_SPI0;			
00001a  4620              MOV      r0,r4
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  1494              ASRS     r4,r2,#18
000020  43a0              BICS     r0,r0,r4
000022  2405              MOVS     r4,#5
000024  0724              LSLS     r4,r4,#28
000026  60e0              STR      r0,[r4,#0xc]
000028  e02b              B        |L24.130|
                  |L24.42|
;;;129    	}	
;;;130    	else if((uint32_t)SpiPort == SPI1_BASE)
00002a  482d              LDR      r0,|L24.224|
00002c  4282              CMP      r2,r0
00002e  d111              BNE      |L24.84|
;;;131    	{	
;;;132    		GCR->IPRST_CTL2 |= GCR_IPRSTCTL2_SPI1;
000030  2005              MOVS     r0,#5
000032  0700              LSLS     r0,r0,#28
000034  68c0              LDR      r0,[r0,#0xc]
000036  2401              MOVS     r4,#1
000038  0364              LSLS     r4,r4,#13
00003a  4320              ORRS     r0,r0,r4
00003c  2405              MOVS     r4,#5
00003e  0724              LSLS     r4,r4,#28
000040  60e0              STR      r0,[r4,#0xc]
;;;133    		GCR->IPRST_CTL2 &= ~GCR_IPRSTCTL2_SPI1;		
000042  4620              MOV      r0,r4
000044  68c0              LDR      r0,[r0,#0xc]
000046  2401              MOVS     r4,#1
000048  0364              LSLS     r4,r4,#13
00004a  43a0              BICS     r0,r0,r4
00004c  2405              MOVS     r4,#5
00004e  0724              LSLS     r4,r4,#28
000050  60e0              STR      r0,[r4,#0xc]
000052  e016              B        |L24.130|
                  |L24.84|
;;;134    	}	
;;;135    	else if((uint32_t)SpiPort == SPI2_BASE)
000054  4823              LDR      r0,|L24.228|
000056  4282              CMP      r2,r0
000058  d111              BNE      |L24.126|
;;;136    	{	
;;;137    		GCR->IPRST_CTL2 |= GCR_IPRSTCTL2_SPI2;
00005a  2005              MOVS     r0,#5
00005c  0700              LSLS     r0,r0,#28
00005e  68c0              LDR      r0,[r0,#0xc]
000060  2401              MOVS     r4,#1
000062  03a4              LSLS     r4,r4,#14
000064  4320              ORRS     r0,r0,r4
000066  2405              MOVS     r4,#5
000068  0724              LSLS     r4,r4,#28
00006a  60e0              STR      r0,[r4,#0xc]
;;;138    		GCR->IPRST_CTL2 &= ~GCR_IPRSTCTL2_SPI2;		
00006c  4620              MOV      r0,r4
00006e  68c0              LDR      r0,[r0,#0xc]
000070  2401              MOVS     r4,#1
000072  03a4              LSLS     r4,r4,#14
000074  43a0              BICS     r0,r0,r4
000076  2405              MOVS     r4,#5
000078  0724              LSLS     r4,r4,#28
00007a  60e0              STR      r0,[r4,#0xc]
00007c  e001              B        |L24.130|
                  |L24.126|
;;;139    	}
;;;140    	else	
;;;141    		return 0;
00007e  2000              MOVS     r0,#0
                  |L24.128|
;;;142    			
;;;143    	/* Check busy*/
;;;144    	i32TimeOut = 0x10000;
;;;145    	while(SpiPort->CTL & SPI_CTL_GO_BUSY)
;;;146    	{
;;;147    		if(i32TimeOut-- <= 0)
;;;148    			return SPI_ERR_BUSY;
;;;149    	}
;;;150    	
;;;151    	/* "i32BitLength = 0" means 32 bits */
;;;152    	if(sParam->i32BitLength == 32)
;;;153    		sParam->i32BitLength = 0;
;;;154    		
;;;155    	SpiPort->CTL = (SpiPort->CTL & ~SPI_CTL_TX_BIT_LEN_MASK) | (sParam->i32BitLength << 3);
;;;156    	
;;;157    	SpiPort->CTL = (SpiPort->CTL & ~0x40000) | sParam->u32Mode;
;;;158    
;;;159    	/* Default to automatic slave select and it is low active */
;;;160    	SpiPort->SSR |= SPI_SSR_AUTOSS;
;;;161    	
;;;162    	/* Transition types */	
;;;163    	SpiPort->CTL = (SpiPort->CTL & ~0x806) | sParam->u32Type;
;;;164    	
;;;165        return E_SUCCESS;
;;;166    }
000080  bd10              POP      {r4,pc}
                  |L24.130|
000082  2301              MOVS     r3,#1                 ;144
000084  041b              LSLS     r3,r3,#16             ;144
000086  e005              B        |L24.148|
                  |L24.136|
000088  4618              MOV      r0,r3                 ;147
00008a  1e5b              SUBS     r3,r3,#1              ;147
00008c  2800              CMP      r0,#0                 ;147
00008e  dc01              BGT      |L24.148|
000090  2000              MOVS     r0,#0                 ;148
000092  e7f5              B        |L24.128|
                  |L24.148|
000094  6810              LDR      r0,[r2,#0]            ;145
000096  07c0              LSLS     r0,r0,#31             ;145
000098  0fc0              LSRS     r0,r0,#31             ;145
00009a  d1f5              BNE      |L24.136|
00009c  6888              LDR      r0,[r1,#8]            ;152
00009e  2820              CMP      r0,#0x20              ;152
0000a0  d101              BNE      |L24.166|
0000a2  2000              MOVS     r0,#0                 ;153
0000a4  6088              STR      r0,[r1,#8]            ;153
                  |L24.166|
0000a6  6810              LDR      r0,[r2,#0]            ;155
0000a8  24f8              MOVS     r4,#0xf8              ;155
0000aa  43a0              BICS     r0,r0,r4              ;155
0000ac  688c              LDR      r4,[r1,#8]            ;155
0000ae  00e4              LSLS     r4,r4,#3              ;155
0000b0  4320              ORRS     r0,r0,r4              ;155
0000b2  6010              STR      r0,[r2,#0]            ;155
0000b4  6810              LDR      r0,[r2,#0]            ;157
0000b6  2401              MOVS     r4,#1                 ;157
0000b8  04a4              LSLS     r4,r4,#18             ;157
0000ba  43a0              BICS     r0,r0,r4              ;157
0000bc  680c              LDR      r4,[r1,#0]            ;157
0000be  4320              ORRS     r0,r0,r4              ;157
0000c0  6010              STR      r0,[r2,#0]            ;157
0000c2  68d0              LDR      r0,[r2,#0xc]          ;160
0000c4  2408              MOVS     r4,#8                 ;160
0000c6  4320              ORRS     r0,r0,r4              ;160
0000c8  60d0              STR      r0,[r2,#0xc]          ;160
0000ca  6810              LDR      r0,[r2,#0]            ;163
0000cc  4c06              LDR      r4,|L24.232|
0000ce  4020              ANDS     r0,r0,r4              ;163
0000d0  684c              LDR      r4,[r1,#4]            ;163
0000d2  4320              ORRS     r0,r0,r4              ;163
0000d4  6010              STR      r0,[r2,#0]            ;163
0000d6  2000              MOVS     r0,#0                 ;165
0000d8  e7d2              B        |L24.128|
;;;167    
                          ENDP

0000da  0000              DCW      0x0000
                  |L24.220|
                          DCD      0x40030000
                  |L24.224|
                          DCD      0x40130000
                  |L24.228|
                          DCD      0x400d0000
                  |L24.232|
                          DCD      0xfffff7f9

                          AREA ||i.SPI_SetBitLength||, CODE, READONLY, ALIGN=1

                  SPI_SetBitLength PROC
;;;188      */
;;;189    void SPI_SetBitLength(SPI_TypeDef *SpiPort, int32_t i32BitLength)
000000  2920              CMP      r1,#0x20
;;;190    {
;;;191    	assert_param(SPI_CHECK_BIT_LENGTH_1);
;;;192       
;;;193        if(i32BitLength == 32)
000002  d100              BNE      |L25.6|
;;;194            i32BitLength = 0;
000004  2100              MOVS     r1,#0
                  |L25.6|
;;;195    
;;;196    	SpiPort->CTL = (SpiPort->CTL & ~SPI_CTL_TX_BIT_LEN_MASK) | (i32BitLength << 3);
000006  6802              LDR      r2,[r0,#0]
000008  23f8              MOVS     r3,#0xf8
00000a  439a              BICS     r2,r2,r3
00000c  00cb              LSLS     r3,r1,#3
00000e  431a              ORRS     r2,r2,r3
000010  6002              STR      r2,[r0,#0]
;;;197    }
000012  4770              BX       lr
;;;198    
                          ENDP


                          AREA ||i.SPI_SetClockFreq||, CODE, READONLY, ALIGN=1

                  SPI_SetClockFreq PROC
;;;224      */
;;;225    uint32_t SPI_SetClockFreq(SPI_TypeDef *SpiPort, uint32_t u32Clock1, uint32_t u32Clock2)
000000  b5fe              PUSH     {r1-r7,lr}
;;;226    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;227        uint32_t u32Div;
;;;228        uint32_t u32Pclk, u32CalculatedSpeed=0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;229        
;;;230        u32Pclk = SPI_GetSourceClockFreq(SpiPort);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       SPI_GetSourceClockFreq
000012  9001              STR      r0,[sp,#4]
;;;231        
;;;232    	if(u32Clock2!=0)
000014  2e00              CMP      r6,#0
000016  d01b              BEQ      |L26.80|
;;;233    	{
;;;234    		u32Div = (((u32Pclk / u32Clock2) + 1) >> 1) - 1;
000018  4631              MOV      r1,r6
00001a  9801              LDR      r0,[sp,#4]
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  1c40              ADDS     r0,r0,#1
000022  0840              LSRS     r0,r0,#1
000024  1e44              SUBS     r4,r0,#1
;;;235    		if(u32Div > 0xFF)
000026  2cff              CMP      r4,#0xff
000028  d900              BLS      |L26.44|
;;;236    		    u32Div = 0xFF;
00002a  24ff              MOVS     r4,#0xff
                  |L26.44|
;;;237    		
;;;238    		u32CalculatedSpeed = u32Pclk / (2*(u32Div+1));
00002c  1c60              ADDS     r0,r4,#1
00002e  0041              LSLS     r1,r0,#1
000030  9801              LDR      r0,[sp,#4]
000032  f7fffffe          BL       __aeabi_uidivmod
000036  9000              STR      r0,[sp,#0]
;;;239    		if(u32CalculatedSpeed > u32Clock2)
000038  9800              LDR      r0,[sp,#0]
00003a  42b0              CMP      r0,r6
00003c  d900              BLS      |L26.64|
;;;240    			u32Div ++;			
00003e  1c64              ADDS     r4,r4,#1
                  |L26.64|
;;;241    		
;;;242    		SpiPort->CLKDIV = (SpiPort->CLKDIV & ~SPI_CLKDIV_DIVIDER2_MASK) | (u32Div << 16);
000040  68a8              LDR      r0,[r5,#8]
000042  21ff              MOVS     r1,#0xff
000044  0409              LSLS     r1,r1,#16
000046  4388              BICS     r0,r0,r1
000048  0421              LSLS     r1,r4,#16
00004a  4308              ORRS     r0,r0,r1
00004c  60a8              STR      r0,[r5,#8]
00004e  e004              B        |L26.90|
                  |L26.80|
;;;243    	}
;;;244    	else
;;;245    		SpiPort->CLKDIV |= SPI_CLKDIV_DIVIDER2_MASK;
000050  68a8              LDR      r0,[r5,#8]
000052  21ff              MOVS     r1,#0xff
000054  0409              LSLS     r1,r1,#16
000056  4308              ORRS     r0,r0,r1
000058  60a8              STR      r0,[r5,#8]
                  |L26.90|
;;;246    	
;;;247    	if(u32Clock1!=0)
00005a  2f00              CMP      r7,#0
00005c  d020              BEQ      |L26.160|
;;;248    	{
;;;249    		u32Div = ((u32Pclk / u32Clock1) >> 1);
00005e  4639              MOV      r1,r7
000060  9801              LDR      r0,[sp,#4]
000062  f7fffffe          BL       __aeabi_uidivmod
000066  0844              LSRS     r4,r0,#1
;;;250    		if(u32Div > 0x7F)
000068  2c7f              CMP      r4,#0x7f
00006a  d900              BLS      |L26.110|
;;;251    		    u32Div = 0x7F;
00006c  247f              MOVS     r4,#0x7f
                  |L26.110|
;;;252    		
;;;253    		if(u32Div == 0)
00006e  2c00              CMP      r4,#0
000070  d102              BNE      |L26.120|
;;;254    			u32CalculatedSpeed = u32Pclk;
000072  9801              LDR      r0,[sp,#4]
000074  9000              STR      r0,[sp,#0]
000076  e004              B        |L26.130|
                  |L26.120|
;;;255    		else
;;;256    			u32CalculatedSpeed = u32Pclk / (u32Div << 1);
000078  0061              LSLS     r1,r4,#1
00007a  9801              LDR      r0,[sp,#4]
00007c  f7fffffe          BL       __aeabi_uidivmod
000080  9000              STR      r0,[sp,#0]
                  |L26.130|
;;;257    		
;;;258    		if(u32CalculatedSpeed > u32Clock1)
000082  9800              LDR      r0,[sp,#0]
000084  42b8              CMP      r0,r7
000086  d905              BLS      |L26.148|
;;;259    		{	
;;;260    			u32Div ++;
000088  1c64              ADDS     r4,r4,#1
;;;261    			u32CalculatedSpeed = u32Pclk / (u32Div << 1);
00008a  0061              LSLS     r1,r4,#1
00008c  9801              LDR      r0,[sp,#4]
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  9000              STR      r0,[sp,#0]
                  |L26.148|
;;;262    		}
;;;263    		
;;;264    		SpiPort->CLKDIV = (SpiPort->CLKDIV & ~SPI_CLKDIV_DIVIDER1_MASK) | u32Div;
000094  68a8              LDR      r0,[r5,#8]
000096  0a00              LSRS     r0,r0,#8
000098  0200              LSLS     r0,r0,#8
00009a  4320              ORRS     r0,r0,r4
00009c  60a8              STR      r0,[r5,#8]
00009e  e003              B        |L26.168|
                  |L26.160|
;;;265    	}
;;;266    	else
;;;267    		SpiPort->CLKDIV |= SPI_CLKDIV_DIVIDER1_MASK;
0000a0  68a8              LDR      r0,[r5,#8]
0000a2  21ff              MOVS     r1,#0xff
0000a4  4308              ORRS     r0,r0,r1
0000a6  60a8              STR      r0,[r5,#8]
                  |L26.168|
;;;268    	
;;;269    	return u32CalculatedSpeed;
0000a8  9800              LDR      r0,[sp,#0]
;;;270    }
0000aa  bdfe              POP      {r1-r7,pc}
;;;271    
                          ENDP


                          AREA ||i.SPI_SetFIFOMode||, CODE, READONLY, ALIGN=1

                  SPI_SetFIFOMode PROC
;;;502      */
;;;503    void SPI_SetFIFOMode(SPI_TypeDef *SpiPort, uint8_t bEnable, int32_t i32Interval)
000000  b510              PUSH     {r4,lr}
;;;504    {    
;;;505        SpiPort->CTL = (SpiPort->CTL & ~SPI_CTL_SP_CYCLE) | (i32Interval << 12);
000002  6803              LDR      r3,[r0,#0]
000004  240f              MOVS     r4,#0xf
000006  0324              LSLS     r4,r4,#12
000008  43a3              BICS     r3,r3,r4
00000a  0314              LSLS     r4,r2,#12
00000c  4323              ORRS     r3,r3,r4
00000e  6003              STR      r3,[r0,#0]
;;;506        if(bEnable)
000010  2900              CMP      r1,#0
000012  d005              BEQ      |L27.32|
;;;507        	SpiPort->CTL |= SPI_CTL_FIFOM;
000014  6803              LDR      r3,[r0,#0]
000016  2401              MOVS     r4,#1
000018  0564              LSLS     r4,r4,#21
00001a  4323              ORRS     r3,r3,r4
00001c  6003              STR      r3,[r0,#0]
00001e  e004              B        |L27.42|
                  |L27.32|
;;;508        else
;;;509        	SpiPort->CTL &= ~SPI_CTL_FIFOM;
000020  6803              LDR      r3,[r0,#0]
000022  2401              MOVS     r4,#1
000024  0564              LSLS     r4,r4,#21
000026  43a3              BICS     r3,r3,r4
000028  6003              STR      r3,[r0,#0]
                  |L27.42|
;;;510    }
00002a  bd10              POP      {r4,pc}
;;;511    
                          ENDP


                          AREA ||i.SPI_SetRxPDMA||, CODE, READONLY, ALIGN=1

                  SPI_SetRxPDMA PROC
;;;429      */
;;;430    void SPI_SetRxPDMA(SPI_TypeDef *SpiPort, uint8_t bEnable)
000000  2900              CMP      r1,#0
;;;431    {
;;;432    	if(bEnable)
000002  d004              BEQ      |L28.14|
;;;433    		SpiPort->PDMA |= SPI_PDMA_RX_DMA_EN;
000004  6b82              LDR      r2,[r0,#0x38]
000006  2302              MOVS     r3,#2
000008  431a              ORRS     r2,r2,r3
00000a  6382              STR      r2,[r0,#0x38]
00000c  e003              B        |L28.22|
                  |L28.14|
;;;434    	else
;;;435    		SpiPort->PDMA &= ~SPI_PDMA_RX_DMA_EN;
00000e  6b82              LDR      r2,[r0,#0x38]
000010  2302              MOVS     r3,#2
000012  439a              BICS     r2,r2,r3
000014  6382              STR      r2,[r0,#0x38]
                  |L28.22|
;;;436    }
000016  4770              BX       lr
;;;437    
                          ENDP


                          AREA ||i.SPI_SetSuspendCycle||, CODE, READONLY, ALIGN=1

                  SPI_SetSuspendCycle PROC
;;;205      */
;;;206    void SPI_SetSuspendCycle(SPI_TypeDef *SpiPort, int32_t i32Interval)
000000  6802              LDR      r2,[r0,#0]
;;;207    {
;;;208        if(SpiPort->CTL & SPI_CTL_FIFOM) 
000002  2301              MOVS     r3,#1
000004  055b              LSLS     r3,r3,#21
000006  421a              TST      r2,r3
000008  d007              BEQ      |L29.26|
;;;209        	SpiPort->CTL = (SpiPort->CTL & ~SPI_CTL_SP_CYCLE) | (i32Interval << 12);
00000a  6802              LDR      r2,[r0,#0]
00000c  230f              MOVS     r3,#0xf
00000e  031b              LSLS     r3,r3,#12
000010  439a              BICS     r2,r2,r3
000012  030b              LSLS     r3,r1,#12
000014  431a              ORRS     r2,r2,r3
000016  6002              STR      r2,[r0,#0]
000018  e007              B        |L29.42|
                  |L29.26|
;;;210        else 
;;;211        {    
;;;212        	assert_param(SPI_CHECK_BYTE_SUS);
;;;213    		SpiPort->CTL = (SpiPort->CTL & ~SPI_CTL_SP_CYCLE) | ((i32Interval-2) << 12);
00001a  6802              LDR      r2,[r0,#0]
00001c  230f              MOVS     r3,#0xf
00001e  031b              LSLS     r3,r3,#12
000020  439a              BICS     r2,r2,r3
000022  1e8b              SUBS     r3,r1,#2
000024  031b              LSLS     r3,r3,#12
000026  431a              ORRS     r2,r2,r3
000028  6002              STR      r2,[r0,#0]
                  |L29.42|
;;;214    	}
;;;215    }
00002a  4770              BX       lr
;;;216    
                          ENDP


                          AREA ||i.SPI_SetTxPDMA||, CODE, READONLY, ALIGN=1

                  SPI_SetTxPDMA PROC
;;;415      */
;;;416    void SPI_SetTxPDMA(SPI_TypeDef *SpiPort, uint8_t bEnable)
000000  2900              CMP      r1,#0
;;;417    {
;;;418    	if(bEnable)
000002  d004              BEQ      |L30.14|
;;;419    		SpiPort->PDMA |= SPI_PDMA_TX_DMA_EN;
000004  6b82              LDR      r2,[r0,#0x38]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6382              STR      r2,[r0,#0x38]
00000c  e003              B        |L30.22|
                  |L30.14|
;;;420    	else
;;;421    		SpiPort->PDMA &= ~SPI_PDMA_TX_DMA_EN;
00000e  6b82              LDR      r2,[r0,#0x38]
000010  0852              LSRS     r2,r2,#1
000012  0052              LSLS     r2,r2,#1
000014  6382              STR      r2,[r0,#0x38]
                  |L30.22|
;;;422    }
000016  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.SPI_SetTxRegister||, CODE, READONLY, ALIGN=1

                  SPI_SetTxRegister PROC
;;;397      */
;;;398    uint32_t SPI_SetTxRegister(SPI_TypeDef *SpiPort, uint32_t *pu32Buf, uint32_t u32DataCount)
000000  4603              MOV      r3,r0
;;;399    {
;;;400    	assert_param(SPI_CHECK_SET_DATAREG_NUM);
;;;401    	
;;;402    	SpiPort->TX0 = pu32Buf[0];
000002  6808              LDR      r0,[r1,#0]
000004  6218              STR      r0,[r3,#0x20]
;;;403    	
;;;404    	if(u32DataCount == 2)
000006  2a02              CMP      r2,#2
000008  d101              BNE      |L31.14|
;;;405    		SpiPort->TX1 = pu32Buf[1];
00000a  6848              LDR      r0,[r1,#4]
00000c  6258              STR      r0,[r3,#0x24]
                  |L31.14|
;;;406    		
;;;407        return u32DataCount;
00000e  4610              MOV      r0,r2
;;;408    }
000010  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.SPI_SingleRead||, CODE, READONLY, ALIGN=1

                  SPI_SingleRead PROC
;;;344      */
;;;345    uint8_t SPI_SingleRead(SPI_TypeDef *SpiPort, uint32_t *pu32Data)
000000  4602              MOV      r2,r0
;;;346    {
;;;347    	if(SpiPort->CTL & SPI_CTL_GO_BUSY)
000002  6810              LDR      r0,[r2,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  d001              BEQ      |L32.14|
;;;348    		return FALSE;
00000a  2000              MOVS     r0,#0
                  |L32.12|
;;;349    
;;;350    	*pu32Data = SpiPort->RX0;
;;;351    	SpiPort->CTL |= SPI_CTL_GO_BUSY;
;;;352    	return TRUE;
;;;353    }
00000c  4770              BX       lr
                  |L32.14|
00000e  6910              LDR      r0,[r2,#0x10]         ;350
000010  6008              STR      r0,[r1,#0]            ;350
000012  6810              LDR      r0,[r2,#0]            ;351
000014  2301              MOVS     r3,#1                 ;351
000016  4318              ORRS     r0,r0,r3              ;351
000018  6010              STR      r0,[r2,#0]            ;351
00001a  2001              MOVS     r0,#1                 ;352
00001c  e7f6              B        |L32.12|
;;;354    
                          ENDP


                          AREA ||i.SPI_SingleWrite||, CODE, READONLY, ALIGN=1

                  SPI_SingleWrite PROC
;;;361      */
;;;362    uint8_t SPI_SingleWrite(SPI_TypeDef *SpiPort, uint32_t *pu32Data)
000000  4602              MOV      r2,r0
;;;363    {
;;;364    	if(SpiPort->CTL & SPI_CTL_GO_BUSY)
000002  6810              LDR      r0,[r2,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  d001              BEQ      |L33.14|
;;;365    		return FALSE;
00000a  2000              MOVS     r0,#0
                  |L33.12|
;;;366    
;;;367    	SpiPort->TX0 = *pu32Data;
;;;368    	SpiPort->CTL |= SPI_CTL_GO_BUSY;
;;;369    	return TRUE;
;;;370    }
00000c  4770              BX       lr
                  |L33.14|
00000e  6808              LDR      r0,[r1,#0]            ;367
000010  6210              STR      r0,[r2,#0x20]         ;367
000012  6810              LDR      r0,[r2,#0]            ;368
000014  2301              MOVS     r3,#1                 ;368
000016  4318              ORRS     r0,r0,r3              ;368
000018  6010              STR      r0,[r2,#0]            ;368
00001a  2001              MOVS     r0,#1                 ;369
00001c  e7f6              B        |L33.12|
;;;371    
                          ENDP


                          AREA ||i.SPI_WakeupConfigure||, CODE, READONLY, ALIGN=1

                  SPI_WakeupConfigure PROC
;;;486      */
;;;487    void SPI_WakeupConfigure(SPI_TypeDef *SpiPort, uint8_t bEnable)
000000  2900              CMP      r1,#0
;;;488    {
;;;489    	if(bEnable)
000002  d005              BEQ      |L34.16|
;;;490    		SpiPort->CTL |= SPI_CTL_WKEUP_EN;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  07db              LSLS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e003              B        |L34.24|
                  |L34.16|
;;;491    	else
;;;492    		SpiPort->CTL &= ~SPI_CTL_WKEUP_EN;
000010  6802              LDR      r2,[r0,#0]
000012  0052              LSLS     r2,r2,#1
000014  0852              LSRS     r2,r2,#1
000016  6002              STR      r2,[r0,#0]
                  |L34.24|
;;;493    }
000018  4770              BX       lr
;;;494    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\nano1xx_spi.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_nano1xx_spi_c_SPI_Init____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_nano1xx_spi_c_SPI_Init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_nano1xx_spi_c_SPI_Init____REVSH|
#line 144
|__asm___13_nano1xx_spi_c_SPI_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
